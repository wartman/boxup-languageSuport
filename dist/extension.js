// Generated by Haxe 4.2.1+bf9ff69
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function BoxupLanguage_activate(context) {
	let reporter = new boxup_ls_diagnostic_DiagnosticReporter();
	let reader = new boxup_ls_loader_TextDocumentLoader();
	let controller = new boxup_ls_command_Controller();
	let worklet = new boxup_ls_Worklet(reporter,controller,reader);
	reporter.register(context);
	reader.register(context);
	controller.register(context);
	worklet.register(context);
}
$hx_exports["activate"] = BoxupLanguage_activate;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedRight() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		let sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
}
EReg.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class Lambda {
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) if(f(x.next())) {
			return true;
		}
		return false;
	}
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
}
Lambda.__name__ = true;
Math.__name__ = true;
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static getProperty(o,field) {
		let tmp;
		if(o == null) {
			return null;
		} else {
			let tmp1;
			if(o.__properties__) {
				tmp = o.__properties__["get_" + field];
				tmp1 = tmp;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return o[tmp]();
			} else {
				return o[field];
			}
		}
	}
	static isObject(v) {
		if(v == null) {
			return false;
		}
		let t = typeof(v);
		if(!(t == "string" || t == "object" && v.__enum__ == null)) {
			if(t == "function") {
				return (v.__name__ || v.__ename__) != null;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = true;
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class Type {
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			return false;
		}
		return true;
	}
}
Type.__name__ = true;
var Vscode = require("vscode");
class boxup_ReadStream {
	constructor() {
		if(boxup_ReadStream._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.closed = false;
		this.onClose = [];
		this.onData = [];
	}
	isReadable() {
		return !this.closed;
	}
	pipe(writable) {
		if(!this.isReadable() || !writable.isWritable()) {
			return;
		}
		this.onData.push($bind(writable,writable.write));
		let listener = function(_) {
			writable.end();
		};
		this.onClose.push(listener);
	}
	close() {
		if(this.closed) {
			return;
		}
		this.closed = true;
		let this1 = this.onClose;
		let _g = 0;
		while(_g < this1.length) this1[_g++](this);
		let this2 = this.onData;
		let _g1 = 0;
		while(_g1 < this2.length) HxOverrides.remove(this2,this2[_g1++]);
		let this3 = this.onClose;
		let _g2 = 0;
		while(_g2 < this3.length) HxOverrides.remove(this3,this3[_g2++]);
	}
}
boxup_ReadStream.__name__ = true;
class boxup_AbstractStream extends boxup_ReadStream {
	constructor() {
		if(boxup_ReadStream._hx_skip_constructor) {
			super();
			return;
		}
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.onEnd = [];
		super._hx_constructor();
	}
	map(stream) {
		this.pipe(stream);
		return stream;
	}
	forward(data) {
		let this1 = this.onData;
		let _g = 0;
		while(_g < this1.length) this1[_g++](data);
	}
	isWritable() {
		return !this.closed;
	}
	end() {
		if(this.closed) {
			return;
		}
		let this1 = this.onEnd;
		let _g = 0;
		while(_g < this1.length) this1[_g++](this);
		let this2 = this.onEnd;
		let _g1 = 0;
		while(_g1 < this2.length) HxOverrides.remove(this2,this2[_g1++]);
		this.close();
	}
}
boxup_AbstractStream.__name__ = true;
class boxup_Error {
	constructor(message,pos) {
		this.message = message;
		this.pos = pos != null ? pos : new boxup_Position(0,0,"<unknown>");
	}
	toString() {
		return "" + this.message + " : " + this.pos.file + " " + this.pos.min + " " + this.pos.max;
	}
}
boxup_Error.__name__ = true;
class boxup_GeneratorStream extends boxup_AbstractStream {
	constructor(generator) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(generator);
	}
	_hx_constructor(generator) {
		this.generator = generator;
		super._hx_constructor();
	}
	write(chunk) {
		let result = chunk.result;
		let data;
		switch(result._hx_index) {
		case 0:
			data = this.generator.generate(result.data,chunk.source);
			break;
		case 1:
			data = boxup_Result.Fail(result.error);
			break;
		}
		let data1 = { result : data, source : chunk.source};
		let this1 = this.onData;
		let _g = 0;
		while(_g < this1.length) this1[_g++](data1);
	}
}
boxup_GeneratorStream.__name__ = true;
var boxup_NodeType = $hxEnums["boxup.NodeType"] = { __ename__:true,__constructs__:null
	,Block: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"boxup.NodeType",toString:$estr}; },$_._hx_name="Block",$_.__params__ = ["name"],$_)
	,Paragraph: {_hx_name:"Paragraph",_hx_index:1,__enum__:"boxup.NodeType",toString:$estr}
	,Text: {_hx_name:"Text",_hx_index:2,__enum__:"boxup.NodeType",toString:$estr}
};
boxup_NodeType.__constructs__ = [boxup_NodeType.Block,boxup_NodeType.Paragraph,boxup_NodeType.Text];
class boxup_Node {
	constructor(type,id,isTag,textContent,properties,children,pos) {
		this.textContent = null;
		this.isTag = false;
		this.id = null;
		this.type = type;
		if(id != null) {
			this.id = id;
		}
		if(isTag != null) {
			this.isTag = isTag;
		}
		if(textContent != null) {
			this.textContent = textContent;
		}
		this.properties = properties;
		this.children = children;
		this.pos = pos;
	}
	getProperty(name,def) {
		let prop = Lambda.find(this.properties,function(p) {
			return p.name == name;
		});
		if(prop == null) {
			return def;
		} else {
			return prop.value.value;
		}
	}
}
boxup_Node.__name__ = true;
class boxup_Parser {
	constructor(tokens) {
		this.position = 0;
		this.tokens = tokens;
	}
	parse() {
		this.position = 0;
		try {
			let _g = [];
			while(!this.isAtEnd()) _g.push(this.parseRoot(0));
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _g.length) {
				let v = _g[_g2];
				++_g2;
				if(v != null) {
					_g1.push(v);
				}
			}
			return boxup_Result.Ok(_g1);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			let _g2 = _g1.unwrap();
			if(((_g2) instanceof boxup_Error)) {
				return boxup_Result.Fail([_g2]);
			} else {
				return boxup_Result.Fail([new boxup_Error(_g1.details(),new boxup_Position(0,0,this.tokens.length != 0 ? this.tokens[0].pos.file : "<unknown>"))]);
			}
		}
	}
	parseRoot(indent) {
		if(indent == null) {
			indent = 0;
		}
		if(this.isAtEnd()) {
			return null;
		}
		if(this.match("<newline>")) {
			return this.parseRoot(0);
		}
		if(this.match("<whitespace>")) {
			return this.parseRoot(indent + 1);
		}
		if(this.match("[/")) {
			this.ignoreComment();
			return this.parseRoot(indent);
		}
		if(this.match("[")) {
			return this.parseBlock(indent);
		}
		return this.parseParagraph(indent);
	}
	parseRootInline(indent) {
		if(this.isAtEnd() || this.isNewline(this.tokens[this.position])) {
			return null;
		}
		this.ignoreWhitespace();
		if(this.match("[/")) {
			this.ignoreComment();
			return this.parseRootInline(indent);
		}
		if(this.match("[")) {
			return this.parseBlock(indent);
		}
		return this.parseParagraph(indent);
	}
	parseBlock(indent,isTag) {
		if(isTag == null) {
			isTag = false;
		}
		this.ignoreWhitespace();
		let properties = [];
		let children = [];
		let id = null;
		let blockName;
		let _g = this.symbol();
		if(_g == null) {
			let name = this.blockIdentifier();
			if(this.match("/")) {
				id = this.parseValue(true);
				if(id == null) {
					throw haxe_Exception.thrown(this.error("Expected an ID",this.tokens[this.position].pos));
				}
			}
			blockName = name;
		} else {
			id = this.parseValue(true);
			blockName = _g;
		}
		this.ignoreWhitespace();
		if(this.tokens[this.position].type != "]") {
			while(true) {
				this.ignoreWhitespaceAndNewline();
				if(this.tokens[this.position].type == "]") {
					break;
				}
				properties.push(this.parseProperty(true));
				if(!(!this.isAtEnd() && this.tokens[this.position].type != "]" && (this.isWhitespace(this.tokens[this.position]) || this.isNewline(this.tokens[this.position])))) {
					break;
				}
			}
		}
		let type = "]";
		if(!this.match(type)) {
			throw haxe_Exception.thrown(this.error("Expected a " + type,this.tokens[this.position].pos));
		}
		let childIndent = 0;
		if(!isTag) {
			this.ignoreWhitespace();
			if(!this.isNewline(this.tokens[this.position])) {
				children.push(this.parseRootInline(indent));
			} else if(this.isPropertyBlock(indent)) {
				while(true) {
					let prev = this.position;
					let tmp;
					let tmp1;
					if(!this.isAtEnd()) {
						childIndent = this.findIndent();
						tmp1 = childIndent > indent;
					} else {
						tmp1 = false;
					}
					if(tmp1) {
						tmp = true;
					} else {
						this.position = prev;
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					if(this.checkIdentifier()) {
						properties.push(this.parseProperty(false));
					}
				}
			} else {
				while(true) {
					let prev = this.position;
					let tmp;
					let tmp1;
					if(!this.isAtEnd()) {
						childIndent = this.findIndent();
						tmp1 = childIndent > indent;
					} else {
						tmp1 = false;
					}
					if(tmp1) {
						tmp = true;
					} else {
						this.position = prev;
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					let _g = this.parseRoot(childIndent);
					if(_g != null) {
						children.push(_g);
					}
				}
			}
		}
		return new boxup_Node(boxup_NodeType.Block(blockName.value),id,isTag,null,properties,children,blockName.pos);
	}
	isPropertyBlock(indent) {
		let start = this.position;
		if(this.findIndent() > indent) {
			if(this.identifier() != null) {
				this.ignoreWhitespace();
				if(this.tokens[this.position].type == "=") {
					this.position = start;
					return true;
				}
			}
		}
		this.position = start;
		return false;
	}
	parseProperty(isInBlockDecl) {
		if(isInBlockDecl == null) {
			isInBlockDecl = true;
		}
		let name = this.identifier();
		if(name == null) {
			throw haxe_Exception.thrown(this.error("Expected an identifier",this.tokens[this.position].pos));
		}
		this.ignoreWhitespace();
		let type = "=";
		if(!this.match(type)) {
			throw haxe_Exception.thrown(this.error("Expected a " + type,this.tokens[this.position].pos));
		}
		this.ignoreWhitespace();
		let value = this.parseValue(isInBlockDecl);
		if(value == null) {
			throw haxe_Exception.thrown(this.error("Expected a value",this.tokens[this.position].pos));
		}
		return { name : name.value, value : value, pos : name.pos};
	}
	parseValue(isInBlockDecl) {
		let tok;
		if(this.match("'")) {
			tok = this.parseString("'");
		} else if(this.match("\"")) {
			tok = this.parseString("\"");
		} else if(isInBlockDecl) {
			let _g = [];
			while(!this.isAtEnd() && this.tokens[this.position].type == "<text>") _g.push(this.advance());
			tok = boxup_TokenTools.merge(_g);
		} else {
			let _g = [];
			while(!this.isAtEnd() && !this.isNewline(this.tokens[this.position])) _g.push(this.advance());
			tok = boxup_TokenTools.merge(_g);
		}
		if(tok == null) {
			return null;
		}
		return { type : this.getType(tok.value), value : tok.value, pos : tok.pos};
	}
	parseParagraph(indent) {
		let start = this.tokens[this.position];
		let children = [];
		while(true) {
			if(this.match("<")) {
				children.push(this.parseTaggedBlock());
			} else if(this.match("_")) {
				children.push(this.parseDecoration("@italic","_"));
			} else if(this.match("*")) {
				children.push(this.parseDecoration("@bold","*"));
			} else if(this.match("`")) {
				children.push(this.parseDecoration("@raw","`"));
			} else {
				children.push(this.parseTextPart(indent));
			}
			if(!(!this.isAtEnd() && !this.isNewline(this.tokens[this.position]))) {
				break;
			}
		}
		let _g = boxup_NodeType.Paragraph;
		let _g1 = [];
		let _g2 = 0;
		while(_g2 < children.length) {
			let v = children[_g2];
			++_g2;
			if(v != null) {
				_g1.push(v);
			}
		}
		return new boxup_Node(_g,null,null,null,[],_g1,boxup_TokenTools.getMergedPos(start,this.tokens[this.position - 1]));
	}
	parseDecoration(name,delimiter) {
		let _g = [];
		while(!this.isAtEnd() && this.tokens[this.position].type != delimiter) _g.push(this.advance());
		let tok = boxup_TokenTools.merge(_g);
		if(!this.match(delimiter)) {
			throw haxe_Exception.thrown(this.error("Expected a " + delimiter,this.tokens[this.position].pos));
		}
		return new boxup_Node(boxup_NodeType.Block(name),null,null,null,[],[new boxup_Node(boxup_NodeType.Text,null,null,tok.value,[],[],tok.pos)],tok.pos);
	}
	parseTaggedBlock() {
		let _g = [];
		while(!this.isAtEnd() && this.tokens[this.position].type != ">") _g.push(this.advance());
		let tagged = boxup_TokenTools.merge(_g);
		let type = ">";
		if(!this.match(type)) {
			throw haxe_Exception.thrown(this.error("Expected a " + type,this.tokens[this.position].pos));
		}
		let type1 = "[";
		if(!this.match(type1)) {
			throw haxe_Exception.thrown(this.error("Expected a " + type1,this.tokens[this.position].pos));
		}
		let block = this.parseBlock(0,true);
		block.children.push(new boxup_Node(boxup_NodeType.Text,null,null,tagged.value,[],[],tagged.pos));
		return block;
	}
	parseTextPart(indent) {
		let _gthis = this;
		let read = function() {
			let _g = [];
			while(!_gthis.isAtEnd() && !_gthis.checkAny(["<","*","_","`","<newline>"])) _g.push(_gthis.advance());
			return boxup_TokenTools.merge(_g);
		};
		let out = [read()];
		let readNext = null;
		readNext = function() {
			while(true) {
				if(!_gthis.isAtEnd()) {
					let pre = _gthis.position;
					if(_gthis.isNewline(_gthis.tokens[_gthis.position])) {
						_gthis.advance();
						if(_gthis.findIndentWithoutNewline() >= indent) {
							if(_gthis.isBlockStart()) {
								_gthis.position = pre;
							} else {
								let part = read();
								if(part == null || part.value.length == 0) {
									_gthis.position = pre;
								} else {
									out.push({ type : part.type, value : " " + StringTools.trim(part.value), pos : part.pos});
									continue;
								}
							}
						} else {
							_gthis.position = pre;
						}
					} else {
						_gthis.position = pre;
					}
				}
				return;
			}
		};
		readNext();
		let tok = boxup_TokenTools.merge(out);
		return new boxup_Node(boxup_NodeType.Text,null,null,tok.value,[],[],tok.pos);
	}
	parseString(delimiter) {
		let _g = [];
		while(!this.isAtEnd() && this.tokens[this.position].type != delimiter) _g.push(this.advance());
		let out = boxup_TokenTools.merge(_g);
		if(this.isAtEnd()) {
			throw haxe_Exception.thrown(this.error("Unterminated string",out.pos));
		}
		if(!this.match(delimiter)) {
			throw haxe_Exception.thrown(this.error("Expected a " + delimiter,this.tokens[this.position].pos));
		}
		return out;
	}
	isBlockStart() {
		return this.tokens[this.position].type == "[";
	}
	symbol() {
		switch(this.tokens[this.position].type) {
		case "!":case "#":case "$":case "%":case "&":case "*":case "+":case "-":case ".":case ":":case "<":case ">":case "?":case "@":case "^":
			return this.advance();
		default:
			return null;
		}
	}
	blockIdentifier() {
		if(!this.checkTokenValueStarts(this.tokens[this.position],$bind(this,this.isUcAlpha))) {
			throw haxe_Exception.thrown(this.error("Expected an uppercase identifier",this.tokens[this.position].pos));
		}
		return this.identifier();
	}
	identifier() {
		let _g = [];
		while(!this.isAtEnd() && this.checkTokenValue(this.tokens[this.position],$bind(this,this.isAlphaNumeric))) _g.push(this.advance());
		return boxup_TokenTools.merge(_g);
	}
	checkIdentifier() {
		return this.checkTokenValue(this.tokens[this.position],$bind(this,this.isAlphaNumeric));
	}
	getType(c) {
		let _gthis = this;
		if(c == "true" || c == "false") {
			return "Bool";
		}
		let isFloat = function() {
			let _g = 0;
			let _g1 = c.length;
			while(_g < _g1) {
				let i = _g++;
				if(!_gthis.isDigit(c.charAt(i)) || c.charAt(i) != ".") {
					return false;
				}
			}
			return true;
		};
		if((function() {
			let _g = 0;
			let _g1 = c.length;
			while(_g < _g1) if(!_gthis.isDigit(c.charAt(_g++))) {
				return false;
			}
			return true;
		})()) {
			return "Int";
		} else if(isFloat()) {
			return "Float";
		} else {
			return "String";
		}
	}
	findIndentWithoutNewline() {
		let found = 0;
		while(!this.isAtEnd() && this.isWhitespace(this.tokens[this.position])) {
			this.advance();
			++found;
		}
		return found;
	}
	findIndent() {
		let found = this.findIndentWithoutNewline();
		if(!this.isAtEnd() && this.isNewline(this.tokens[this.position])) {
			this.advance();
			return this.findIndent();
		}
		if(!this.isAtEnd() && this.tokens[this.position].type == "[/") {
			this.ignoreComment();
			this.ignoreWhitespace();
			if(this.isNewline(this.tokens[this.position])) {
				this.advance();
				return this.findIndent();
			}
		}
		return found;
	}
	ignoreWhitespace() {
		while(!this.isAtEnd()) if(this.match("[/")) {
			this.ignoreComment();
		} else if(!this.isAtEnd() && this.isWhitespace(this.tokens[this.position])) {
			this.advance();
		} else {
			break;
		}
	}
	ignoreWhitespaceAndNewline() {
		let _g = [];
		while(!this.isAtEnd() && (this.isWhitespace(this.tokens[this.position]) || this.isNewline(this.tokens[this.position]))) _g.push(this.advance());
	}
	ignoreComment() {
		let _g = [];
		while(!this.isAtEnd() && this.tokens[this.position].type != "/]") _g.push(this.advance());
		if(!this.isAtEnd()) {
			let type = "/]";
			if(!this.match(type)) {
				throw haxe_Exception.thrown(this.error("Expected a " + type,this.tokens[this.position].pos));
			}
		}
	}
	isNewline(token) {
		return token.type == "<newline>";
	}
	isWhitespace(token) {
		return token.type == "<whitespace>";
	}
	isDigit(c) {
		if(c >= "0") {
			return c <= "9";
		} else {
			return false;
		}
	}
	isUcAlpha(c) {
		if(c >= "A") {
			return c <= "Z";
		} else {
			return false;
		}
	}
	isAlpha(c) {
		if(!(c >= "a" && c <= "z" || c >= "A" && c <= "Z")) {
			return c == "_";
		} else {
			return true;
		}
	}
	isAlphaNumeric(c) {
		if(!this.isAlpha(c)) {
			return this.isDigit(c);
		} else {
			return true;
		}
	}
	checkTokenValueStarts(token,comp) {
		if(token.value.length == 0) {
			return false;
		}
		return comp(token.value.charAt(0));
	}
	checkTokenValue(token,comp) {
		if(token.value.length == 0) {
			return false;
		}
		let _g = 0;
		let _g1 = token.value.length;
		while(_g < _g1) if(!comp(token.value.charAt(_g++))) {
			return false;
		}
		return true;
	}
	match(type) {
		if(this.tokens[this.position].type == type) {
			this.advance();
			return true;
		}
		return false;
	}
	checkAny(types) {
		let _g = 0;
		while(_g < types.length) if(this.tokens[this.position].type == types[_g++]) {
			return true;
		}
		return false;
	}
	advance() {
		if(!this.isAtEnd()) {
			this.position++;
		}
		return this.tokens[this.position - 1];
	}
	isAtEnd() {
		if(this.position < this.tokens.length) {
			return this.tokens[this.position].type == "<eof>";
		} else {
			return true;
		}
	}
	error(msg,pos) {
		return new boxup_Error(msg,pos);
	}
}
boxup_Parser.__name__ = true;
class boxup_ParserStream extends boxup_AbstractStream {
	constructor() {
		super();
	}
	write(chunk) {
		let result = chunk.result;
		let data;
		switch(result._hx_index) {
		case 0:
			data = new boxup_Parser(result.data).parse();
			break;
		case 1:
			data = boxup_Result.Fail(result.error);
			break;
		}
		let data1 = { result : data, source : chunk.source};
		let this1 = this.onData;
		let _g = 0;
		while(_g < this1.length) this1[_g++](data1);
	}
}
boxup_ParserStream.__name__ = true;
class boxup_Position {
	constructor(min,max,file) {
		this.min = min;
		this.max = max;
		this.file = file;
	}
}
boxup_Position.__name__ = true;
class boxup_ReporterStream extends boxup_AbstractStream {
	constructor(reporter) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(reporter);
	}
	_hx_constructor(reporter) {
		this.reporter = reporter;
		super._hx_constructor();
	}
	write(chunk) {
		let result = chunk.result;
		switch(result._hx_index) {
		case 0:
			break;
		case 1:
			this.reporter.report(result.error,chunk.source);
			break;
		}
		let this1 = this.onData;
		let _g = 0;
		while(_g < this1.length) this1[_g++](chunk);
	}
}
boxup_ReporterStream.__name__ = true;
var boxup_Result = $hxEnums["boxup.Result"] = { __ename__:true,__constructs__:null
	,Ok: ($_=function(data) { return {_hx_index:0,data:data,__enum__:"boxup.Result",toString:$estr}; },$_._hx_name="Ok",$_.__params__ = ["data"],$_)
	,Fail: ($_=function(error) { return {_hx_index:1,error:error,__enum__:"boxup.Result",toString:$estr}; },$_._hx_name="Fail",$_.__params__ = ["error"],$_)
};
boxup_Result.__constructs__ = [boxup_Result.Ok,boxup_Result.Fail];
class boxup_Scanner {
	constructor(source) {
		this.start = 0;
		this.position = 0;
		this.source = source;
	}
	scan() {
		this.position = 0;
		this.start = 0;
		try {
			let _g = [];
			while(!this.isAtEnd()) _g.push(this.scanToken());
			_g.push({ type : "<eof>", value : "", pos : new boxup_Position(this.position,this.position,this.source.filename)});
			return boxup_Result.Ok(_g);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			let _g2 = _g1.unwrap();
			if(((_g2) instanceof boxup_Error)) {
				return boxup_Result.Fail([_g2]);
			} else {
				return boxup_Result.Fail([this.error(_g1.details(),0,0)]);
			}
		}
	}
	scanToken() {
		this.start = this.position;
		let r = this.advance();
		let _gthis = this;
		switch(r) {
		case "\n":
			return this.createToken("<newline>");
		case "\r":
			if(this.match("\n")) {
				return this.createToken("<newline>","\r\n");
			} else {
				return { type : "<text>", value : r + this.readWhile(function() {
					return _gthis.isAlphaNumeric(_gthis.peek());
				}), pos : new boxup_Position(this.start,this.position,this.source.filename)};
			}
			break;
		case " ":
			return this.createToken("<whitespace>");
		case "!":
			return this.createToken("!");
		case "\"":
			return this.createToken("\"");
		case "#":
			return this.createToken("#");
		case "$":
			return this.createToken("$");
		case "%":
			return this.createToken("%");
		case "&":
			return this.createToken("&");
		case "'":
			return this.createToken("'");
		case "*":
			return this.createToken("*");
		case "+":
			return this.createToken("+");
		case "-":
			return this.createToken("-");
		case ".":
			return this.createToken(".");
		case "/":
			if(this.match("]")) {
				return this.createToken("/]","/]");
			} else {
				return this.createToken("/");
			}
			break;
		case ":":
			return this.createToken(":");
		case "<":
			return this.createToken("<");
		case "=":
			return this.createToken("=");
		case ">":
			return this.createToken(">");
		case "?":
			return this.createToken("?");
		case "@":
			return this.createToken("@");
		case "[":
			if(this.match("/")) {
				return this.createToken("[/","[/");
			} else {
				return this.createToken("[");
			}
			break;
		case "\\":
			return this.createToken("<text>",this.advance());
		case "]":
			return this.createToken("]");
		case "^":
			return this.createToken("^");
		case "_":
			return this.createToken("_");
		case "`":
			return this.createToken("`");
		default:
			return { type : "<text>", value : r + this.readWhile(function() {
				return _gthis.isAlphaNumeric(_gthis.peek());
			}), pos : new boxup_Position(this.start,this.position,this.source.filename)};
		}
	}
	createToken(type,value) {
		return { type : type, value : value == null ? this.previous() : value, pos : new boxup_Position(this.start,this.position,this.source.filename)};
	}
	match(value) {
		if(this.check(value)) {
			this.position += value.length;
			return true;
		}
		return false;
	}
	check(value) {
		return HxOverrides.substr(this.source.content,this.position,value.length) == value;
	}
	peek() {
		return this.source.content.charAt(this.position);
	}
	advance() {
		if(!this.isAtEnd()) {
			this.position++;
		}
		return this.previous();
	}
	previous() {
		return this.source.content.charAt(this.position - 1);
	}
	isDigit(c) {
		if(c >= "0") {
			return c <= "9";
		} else {
			return false;
		}
	}
	isAlpha(c) {
		if(!(c >= "a" && c <= "z")) {
			if(c >= "A") {
				return c <= "Z";
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	isAlphaNumeric(c) {
		if(!this.isAlpha(c)) {
			return this.isDigit(c);
		} else {
			return true;
		}
	}
	readWhile(compare) {
		let _g = [];
		while(!this.isAtEnd() && compare()) _g.push(this.advance());
		return _g.join("");
	}
	isAtEnd() {
		return this.position >= this.source.content.length;
	}
	error(msg,min,max) {
		return new boxup_Error(msg,new boxup_Position(min,max,this.source.filename));
	}
}
boxup_Scanner.__name__ = true;
class boxup_ScannerStream extends boxup_AbstractStream {
	constructor() {
		super();
	}
	write(result) {
		switch(result._hx_index) {
		case 0:
			let _g = result.data;
			let data = { result : new boxup_Scanner(_g).scan(), source : _g};
			let this1 = this.onData;
			let _g1 = 0;
			while(_g1 < this1.length) this1[_g1++](data);
			break;
		case 1:
			break;
		}
		switch(result._hx_index) {
		case 0:
			break;
		case 1:
			let data1 = { result : boxup_Result.Fail(result.error), source : boxup_Source.none()};
			let this2 = this.onData;
			let _g2 = 0;
			while(_g2 < this2.length) this2[_g2++](data1);
			break;
		}
	}
}
boxup_ScannerStream.__name__ = true;
class boxup_Source {
	constructor(filename,content) {
		this.filename = filename;
		this.content = content;
	}
	static none() {
		return new boxup_Source("<unknown>","");
	}
}
boxup_Source.__name__ = true;
class boxup_TokenTools {
	static merge(tokens) {
		let _g = [];
		let _g1 = 0;
		let _g2 = tokens;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v != null) {
				_g.push(v);
			}
		}
		tokens = _g;
		if(_g.length == 0) {
			return null;
		}
		if(_g.length == 1) {
			return _g[0];
		}
		let result = new Array(_g.length);
		let _g3 = 0;
		let _g4 = _g.length;
		while(_g3 < _g4) {
			let i = _g3++;
			result[i] = _g[i].value;
		}
		return { type : "<text>", value : result.join(""), pos : boxup_TokenTools.getMergedPos(_g[0],_g[_g.length - 1])};
	}
	static getMergedPos(a,b) {
		return new boxup_Position(a.pos.min,b.pos.max,a.pos.file);
	}
}
boxup_TokenTools.__name__ = true;
class boxup_ValidatorStream extends boxup_AbstractStream {
	constructor(validator) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(validator);
	}
	_hx_constructor(validator) {
		this.validator = validator;
		super._hx_constructor();
	}
	write(chunk) {
		let result = chunk.result;
		let data;
		switch(result._hx_index) {
		case 0:
			data = this.validator.validate(result.data,chunk.source);
			break;
		case 1:
			data = boxup_Result.Fail(result.error);
			break;
		}
		let data1 = { result : data, source : chunk.source};
		let this1 = this.onData;
		let _g = 0;
		while(_g < this1.length) this1[_g++](data1);
	}
}
boxup_ValidatorStream.__name__ = true;
class boxup_WriteStream {
	constructor(handler,finisher) {
		if(boxup_WriteStream._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(handler,finisher);
	}
	_hx_constructor(handler,finisher) {
		this.closed = false;
		this.onEnd = [];
		this.handler = handler;
		if(finisher != null) {
			let listener = function(_) {
				finisher();
			};
			this.onEnd.push(listener);
		}
	}
	isWritable() {
		return !this.closed;
	}
	write(value) {
		if(this.isWritable()) {
			this.handler(value);
		}
	}
	end() {
		if(this.closed) {
			return;
		}
		this.closed = true;
		let this1 = this.onEnd;
		let data = null;
		let _g = 0;
		while(_g < this1.length) this1[_g++](data);
		let this2 = this.onEnd;
		let _g1 = 0;
		while(_g1 < this2.length) HxOverrides.remove(this2,this2[_g1++]);
	}
}
boxup_WriteStream.__name__ = true;
class boxup_cli_Config {
	constructor(definitionRoot,definitionSuffix,tasks) {
		this.definitionRoot = definitionRoot;
		this.definitionSuffix = definitionSuffix;
		this.tasks = tasks;
	}
}
boxup_cli_Config.__name__ = true;
class boxup_cli_ConfigTask {
	constructor(source,destination,generator,filter,extension) {
		this.source = source;
		this.destination = destination;
		this.generator = generator;
		this.filter = filter;
		this.extension = extension;
	}
}
boxup_cli_ConfigTask.__name__ = true;
class boxup_cli_ConfigGenerator {
	constructor() {
	}
	generate(nodes,source) {
		let definitions = Lambda.find(nodes,function(n) {
			return Type.enumEq(n.type,boxup_NodeType.Block("Definitions"));
		});
		let _g = [];
		let _g1 = 0;
		while(_g1 < nodes.length) {
			let v = nodes[_g1];
			++_g1;
			if(Type.enumEq(v.type,boxup_NodeType.Block("Compile"))) {
				_g.push(v);
			}
		}
		let root = haxe_io_Path.directory(source.filename);
		let _g2 = definitions.getProperty("suffix","d");
		let _g3 = haxe_io_Path.join([root,definitions.getProperty("root")]);
		let _g4 = [];
		let _g5 = 0;
		while(_g5 < _g.length) {
			let task = _g[_g5];
			++_g5;
			let _g1 = haxe_io_Path.join([root,task.getProperty("source")]);
			let _g2 = haxe_io_Path.join([root,task.getProperty("destination")]);
			let _g3 = task.getProperty("generator");
			let _this = task.getProperty("filter").split(",");
			let result = new Array(_this.length);
			let _g6 = 0;
			let _g7 = _this.length;
			while(_g6 < _g7) {
				let i = _g6++;
				result[i] = StringTools.trim(_this[i]);
			}
			_g4.push(new boxup_cli_ConfigTask(_g1,_g2,_g3,result,task.getProperty("extension",task.getProperty("generator"))));
		}
		return boxup_Result.Ok(new boxup_cli_Config(_g3,_g2,_g4));
	}
}
boxup_cli_ConfigGenerator.__name__ = true;
class boxup_cli_ConfigStream extends boxup_AbstractStream {
	constructor(allowedGenerators) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(allowedGenerators);
	}
	_hx_constructor(allowedGenerators) {
		this.allowedGenerators = allowedGenerators;
		super._hx_constructor();
	}
	write(result) {
		let scanner = new boxup_ScannerStream();
		let tmp = boxup_cli_ConfigValidator.create(this.allowedGenerators);
		scanner.map(new boxup_ParserStream()).map(new boxup_ValidatorStream(tmp)).map(new boxup_GeneratorStream(new boxup_cli_ConfigGenerator())).pipe(new boxup_WriteStream($bind(this,this.forward)));
		scanner.write(result);
	}
}
boxup_cli_ConfigStream.__name__ = true;
class boxup_cli_ConfigValidator {
	static create(allowedGenerators) {
		return new boxup_cli_Definition("config",[new boxup_cli_BlockDefinition("@root",null,null,[new boxup_cli_ChildDefinition("Definitions",null,true,false),new boxup_cli_ChildDefinition("Compile",null,null,null)],[]),new boxup_cli_BlockDefinition("Definitions",null,null,[],[new boxup_cli_PropertyDefinition("root",null,true,null,null),new boxup_cli_PropertyDefinition("suffix",null,false,null,null)]),new boxup_cli_BlockDefinition("Compile",null,null,[],[new boxup_cli_PropertyDefinition("source",null,true,null,null),new boxup_cli_PropertyDefinition("destination",null,true,null,null),new boxup_cli_PropertyDefinition("extension",null,null,null,null),new boxup_cli_PropertyDefinition("generator",null,true,null,allowedGenerators),new boxup_cli_PropertyDefinition("filter",null,true,null,null)])],new haxe_ds_StringMap());
	}
}
boxup_cli_ConfigValidator.__name__ = true;
class boxup_cli_Context {
	constructor(config,definitions) {
		this.config = config;
		this.definitions = definitions;
	}
}
boxup_cli_Context.__name__ = true;
class boxup_cli_ContextStream extends boxup_AbstractStream {
	constructor(resolver) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(resolver);
	}
	_hx_constructor(resolver) {
		this.resolver = resolver;
		super._hx_constructor();
	}
	write(chunk) {
		let _gthis = this;
		let result = chunk.result;
		switch(result._hx_index) {
		case 0:
			let config = result.data;
			let errorsEncountered = false;
			let reader = new boxup_cli_loader_DirectoryLoader(config.definitionRoot);
			let manager = new boxup_cli_DefinitionManager(_gthis.resolver);
			let scanner = new boxup_ScannerStream();
			scanner.map(new boxup_ParserStream()).map(new boxup_ValidatorStream(boxup_cli_DefinitionValidator_validator)).map(new boxup_GeneratorStream(new boxup_cli_DefinitionGenerator())).pipe(new boxup_WriteStream(function(chunk) {
				let result = chunk.result;
				switch(result._hx_index) {
				case 0:
					manager.addDefinition(result.data);
					break;
				case 1:
					break;
				}
				switch(result._hx_index) {
				case 0:
					break;
				case 1:
					errorsEncountered = true;
					let data = { result : boxup_Result.Fail(result.error), source : chunk.source};
					let this1 = _gthis.onData;
					let _g = 0;
					while(_g < this1.length) this1[_g++](data);
					break;
				}
			},function() {
				if(!errorsEncountered) {
					let data = { result : boxup_Result.Ok(new boxup_cli_Context(config,manager)), source : chunk.source};
					let this1 = _gthis.onData;
					let _g = 0;
					while(_g < this1.length) this1[_g++](data);
				}
			}));
			reader.pipe(scanner);
			reader.load();
			break;
		case 1:
			break;
		}
		let result1 = chunk.result;
		switch(result1._hx_index) {
		case 0:
			break;
		case 1:
			let this1 = _gthis.onData;
			let data = { result : boxup_Result.Fail(result1.error), source : chunk.source};
			let _g = 0;
			while(_g < this1.length) this1[_g++](data);
			break;
		}
	}
}
boxup_cli_ContextStream.__name__ = true;
class boxup_cli_Definition {
	constructor(id,blocks,meta) {
		this.id = id;
		this.blocks = blocks;
		this.meta = meta;
	}
	getBlock(name) {
		return Lambda.find(this.blocks,function(b) {
			return b.name == name;
		});
	}
	getMeta(name,def) {
		if(Object.prototype.hasOwnProperty.call(this.meta.h,name)) {
			return this.meta.h[name];
		} else {
			return def;
		}
	}
	validate(nodes,source) {
		let result = new boxup_Node(boxup_NodeType.Block("@root"),null,null,null,[],nodes,new boxup_Position(0,0,nodes[0].pos.file));
		let result1 = this.getBlock("@root").validate(result,this);
		switch(result1._hx_index) {
		case 0:
			return boxup_Result.Ok(nodes);
		case 1:
			return boxup_Result.Fail(result1.error);
		}
	}
}
boxup_cli_Definition.__name__ = true;
class boxup_cli_BlockDefinition {
	constructor(name,meta,kind,children,properties) {
		this.kind = "Normal";
		this.meta = new haxe_ds_StringMap();
		this.name = name;
		if(meta != null) {
			this.meta = meta;
		}
		if(kind != null) {
			this.kind = kind;
		}
		this.children = children;
		this.properties = properties;
	}
	get_isParagraph() {
		return this.kind == "Paragraph";
	}
	get_isTag() {
		return this.kind == "Tag";
	}
	getIdProperty() {
		let prop = Lambda.find(this.properties,function(p) {
			return p.isId;
		});
		if(prop != null) {
			return prop.name;
		} else {
			return null;
		}
	}
	getMeta(name,def) {
		if(Object.prototype.hasOwnProperty.call(this.meta.h,name)) {
			return this.meta.h[name];
		} else {
			return def;
		}
	}
	validate(node,definition) {
		let _gthis = this;
		let errors = [];
		let existingChildren = [];
		switch(this.kind) {
		case "Paragraph":
			if(node.properties.length > 0) {
				errors.push(new boxup_Error("Properties are not allowed in paragraph blocks",node.properties[0].pos));
			}
			break;
		case "Normal":case "PropertyBag":case "Tag":
			let result = this.validateProps(node);
			switch(result._hx_index) {
			case 0:
				break;
			case 1:
				let _e = errors;
				(function(errors) {
					let _g = 0;
					let _g1 = errors;
					while(_g < _g1.length) _e.push(_g1[_g++]);
					return _e;
				})(result.error);
				break;
			}
			break;
		default:
		}
		let validateChild = function(name,child) {
			if(Lambda.exists(_gthis.children,function(c) {
				return c.symbol == name;
			})) {
				let def = Lambda.find(_gthis.children,function(c) {
					return c.symbol == name;
				});
				name = def.name;
				child.type = boxup_NodeType.Block(def.name);
			}
			if(!Lambda.exists(_gthis.children,function(c) {
				return c.name == name;
			})) {
				errors.push(new boxup_Error("The block " + name + " is an invalid child for " + _gthis.name,child.pos));
			}
			let childDef = Lambda.find(_gthis.children,function(c) {
				return c.name == name;
			});
			let block = definition.getBlock(name);
			if(childDef == null) {
				errors.push(new boxup_Error("Child not allowed: " + name,child.pos));
			} else if(block == null) {
				errors.push(new boxup_Error("Unknown block type: " + name,child.pos));
			} else if(existingChildren.includes(name) && childDef.multiple == false) {
				errors.push(new boxup_Error("Only one " + name + " block is allowed for " + _gthis.name,child.pos));
			} else {
				existingChildren.push(name);
				let result = block.validate(child,definition);
				switch(result._hx_index) {
				case 0:
					break;
				case 1:
					let _e = errors;
					(function(errors) {
						let _g = 0;
						let _g1 = errors;
						while(_g < _g1.length) _e.push(_g1[_g++]);
						return _e;
					})(result.error);
					break;
				}
			}
		};
		let _g = 0;
		let _g1 = node.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.type;
			switch(_g2._hx_index) {
			case 0:
				validateChild(_g2.name,child);
				break;
			case 1:
				let para = null;
				let _g3 = 0;
				let _g4 = this.children;
				while(_g3 < _g4.length) {
					let b = definition.getBlock(_g4[_g3++].name);
					if(b.get_isParagraph()) {
						para = b;
					}
				}
				if(para == null) {
					errors.push(new boxup_Error("No Paragraphs are allowed here",child.pos));
				} else {
					validateChild(para.name,child);
				}
				break;
			case 2:
				if(!this.get_isTag() && !this.get_isParagraph()) {
					errors.push(new boxup_Error("Invalid child",child.pos));
				}
				break;
			}
		}
		let _g2 = 0;
		let _g3 = this.children;
		while(_g2 < _g3.length) {
			let child = _g3[_g2];
			++_g2;
			if(child.required && !existingChildren.includes(child.name)) {
				errors.push(new boxup_Error("Requires a " + child.name + " block",node.pos));
			}
		}
		if(errors.length > 0) {
			return boxup_Result.Fail(errors);
		} else {
			return boxup_Result.Ok(node);
		}
	}
	validateProps(node) {
		let found = [];
		let _g = this.getIdProperty();
		if(_g == null) {
			if(node.id != null) {
				return boxup_Result.Fail([new boxup_Error("Unexpected id",node.id.pos)]);
			}
		} else {
			let name = _g;
			if(!Lambda.exists(node.properties,function(n) {
				return n.name == name;
			}) && node.id != null) {
				node.properties.push({ name : name, value : node.id, pos : node.id.pos});
			}
		}
		let _g1 = 0;
		let _g2 = node.properties;
		while(_g1 < _g2.length) {
			let prop = _g2[_g1];
			++_g1;
			let def = Lambda.find(this.properties,function(p) {
				return p.name == prop.name;
			});
			if(def == null) {
				if(this.kind == "PropertyBag") {
					continue;
				}
				return boxup_Result.Fail([new boxup_Error("Invalid property: " + prop.name,prop.pos)]);
			}
			if(found.includes(prop.name)) {
				return boxup_Result.Fail([new boxup_Error("Duplicate property",prop.pos)]);
			}
			found.push(prop.name);
			if(prop.value.type != def.type) {
				return boxup_Result.Fail([new boxup_Error("Should be a " + def.type + " but was a " + prop.value.type,prop.value.pos)]);
			}
			if(def.allowedValues.length > 0 && !def.allowedValues.includes(prop.value.value)) {
				return boxup_Result.Fail([new boxup_Error("Value must be one of: " + def.allowedValues.join(", "),prop.value.pos)]);
			}
		}
		let _g3 = 0;
		let _g4 = this.properties;
		while(_g3 < _g4.length) {
			let def = _g4[_g3];
			++_g3;
			if(def.required && !found.includes(def.name)) {
				return boxup_Result.Fail([new boxup_Error("Requires property " + def.name,node.pos)]);
			}
		}
		return boxup_Result.Ok();
	}
}
boxup_cli_BlockDefinition.__name__ = true;
Object.assign(boxup_cli_BlockDefinition.prototype, {
	__properties__: {get_isTag: "get_isTag",get_isParagraph: "get_isParagraph"}
});
class boxup_cli_ChildDefinition {
	constructor(name,symbol,required,multiple) {
		this.multiple = true;
		this.required = false;
		this.symbol = null;
		this.name = name;
		if(symbol != null) {
			this.symbol = symbol;
		}
		if(required != null) {
			this.required = required;
		}
		if(multiple != null) {
			this.multiple = multiple;
		}
	}
}
boxup_cli_ChildDefinition.__name__ = true;
class boxup_cli_PropertyDefinition {
	constructor(name,isId,required,type,allowedValues) {
		this.allowedValues = [];
		this.type = "String";
		this.required = false;
		this.isId = false;
		this.name = name;
		if(isId != null) {
			this.isId = isId;
		}
		if(required != null) {
			this.required = required;
		}
		if(type != null) {
			this.type = type;
		}
		if(allowedValues != null) {
			this.allowedValues = allowedValues;
		}
	}
}
boxup_cli_PropertyDefinition.__name__ = true;
class boxup_cli_DefinitionGenerator {
	constructor() {
	}
	generate(nodes,source) {
		let blocks = [].concat(boxup_cli_DefinitionGenerator.defaultBlocks);
		let meta = new haxe_ds_StringMap();
		let id;
		let _g = haxe_io_Path.withoutDirectory(source.filename).split(".");
		switch(_g.length) {
		case 2:
			id = _g[1] == "box" ? _g[0] : "<unknown>";
			break;
		case 3:
			id = _g[1] == "d" ? _g[2] == "box" ? _g[0] : "<unknown>" : "<unknown>";
			break;
		default:
			id = "<unknown>";
		}
		let _g1 = 0;
		while(_g1 < nodes.length) {
			let node = nodes[_g1];
			++_g1;
			let _g = node.type;
			if(_g._hx_index == 0) {
				switch(_g.name) {
				case "Block":
					let kind = node.getProperty("kind","Normal");
					let _g2 = node.getProperty("name");
					let _g3 = kind;
					let meta1 = new haxe_ds_StringMap();
					let _g4 = 0;
					let _this = node.children;
					let _g5 = [];
					let _g6 = 0;
					while(_g6 < _this.length) {
						let v = _this[_g6];
						++_g6;
						let _g = v.type;
						if(_g._hx_index == 0 && _g.name == "Meta") {
							_g5.push(v);
						}
					}
					while(_g4 < _g5.length) {
						let node = _g5[_g4];
						++_g4;
						let _g = 0;
						let _g1 = node.properties;
						while(_g < _g1.length) {
							let prop = _g1[_g];
							++_g;
							if(prop.name != "metaNamespace") {
								meta1.h[node.id != null ? node.id.value + "." + prop.name : prop.name] = prop.value.value;
							}
						}
					}
					let _g7;
					if(kind == null) {
						let _this = node.children;
						let _g = [];
						let _g1 = 0;
						while(_g1 < _this.length) {
							let v = _this[_g1];
							++_g1;
							let _g2 = v.type;
							if(_g2._hx_index == 0 && _g2.name == "Child") {
								_g.push(v);
							}
						}
						let result = new Array(_g.length);
						let _g2 = 0;
						let _g3 = _g.length;
						while(_g2 < _g3) {
							let i = _g2++;
							let n = _g[i];
							result[i] = new boxup_cli_ChildDefinition(n.getProperty("name"),n.getProperty("symbol"),n.getProperty("required","false") == "true",n.getProperty("multiple","true") == "true");
						}
						_g7 = result;
					} else if(kind == "Paragraph") {
						let _this = node.children;
						let _g = [];
						let _g1 = 0;
						while(_g1 < _this.length) {
							let v = _this[_g1];
							++_g1;
							let _g2 = v.type;
							if(_g2._hx_index == 0 && _g2.name == "Child") {
								_g.push(v);
							}
						}
						let result = new Array(_g.length);
						let _g2 = 0;
						let _g3 = _g.length;
						while(_g2 < _g3) {
							let i = _g2++;
							let n = _g[i];
							result[i] = new boxup_cli_ChildDefinition(n.getProperty("name"),n.getProperty("symbol"),n.getProperty("required","false") == "true",n.getProperty("multiple","true") == "true");
						}
						_g7 = boxup_cli_DefinitionGenerator.defaultParagraphChildren.concat(result);
					} else {
						let _this = node.children;
						let _g = [];
						let _g1 = 0;
						while(_g1 < _this.length) {
							let v = _this[_g1];
							++_g1;
							let _g2 = v.type;
							if(_g2._hx_index == 0 && _g2.name == "Child") {
								_g.push(v);
							}
						}
						let result = new Array(_g.length);
						let _g2 = 0;
						let _g3 = _g.length;
						while(_g2 < _g3) {
							let i = _g2++;
							let n = _g[i];
							result[i] = new boxup_cli_ChildDefinition(n.getProperty("name"),n.getProperty("symbol"),n.getProperty("required","false") == "true",n.getProperty("multiple","true") == "true");
						}
						_g7 = result;
					}
					let _this1 = node.children;
					let _g8 = [];
					let _g9 = 0;
					while(_g9 < _this1.length) {
						let v = _this1[_g9];
						++_g9;
						let tmp;
						let _g = v.type;
						if(_g._hx_index == 0) {
							switch(_g.name) {
							case "EnumProperty":case "IdProperty":case "Property":
								tmp = true;
								break;
							default:
								tmp = false;
							}
						} else {
							tmp = false;
						}
						if(tmp) {
							_g8.push(v);
						}
					}
					let result = new Array(_g8.length);
					let _g10 = 0;
					let _g11 = _g8.length;
					while(_g10 < _g11) {
						let i = _g10++;
						let n = _g8[i];
						let _g = n.getProperty("name");
						let _g1 = n.getProperty("required") == "true";
						let _g2 = n.type;
						let _g3 = _g2._hx_index == 0 && _g2.name == "IdProperty";
						let _g4 = n.getProperty("type") != null ? n.getProperty("type") : "String";
						let _g5 = n.type;
						let tmp;
						if(_g5._hx_index == 0) {
							if(_g5.name == "EnumProperty") {
								let _this = n.children;
								let _g = [];
								let _g1 = 0;
								while(_g1 < _this.length) {
									let v = _this[_g1];
									++_g1;
									let _g2 = v.type;
									if(_g2._hx_index == 0 && _g2.name == "Option") {
										_g.push(v);
									}
								}
								let result = new Array(_g.length);
								let _g2 = 0;
								let _g3 = _g.length;
								while(_g2 < _g3) {
									let i = _g2++;
									result[i] = _g[i].getProperty("value");
								}
								tmp = result;
							} else {
								tmp = [];
							}
						} else {
							tmp = [];
						}
						result[i] = new boxup_cli_PropertyDefinition(_g,_g3,_g1,_g4,tmp);
					}
					blocks.push(new boxup_cli_BlockDefinition(_g2,meta1,_g3,_g7,result));
					break;
				case "Definition":
					id = node.getProperty("id");
					break;
				case "Meta":
					let _g12 = 0;
					let _g13 = node.properties;
					while(_g12 < _g13.length) {
						let prop = _g13[_g12];
						++_g12;
						if(prop.name != "metaNamespace") {
							meta.h[node.id != null ? node.id.value + "." + prop.name : prop.name] = prop.value.value;
						}
					}
					break;
				case "Root":
					let _this2 = node.children;
					let _g14 = [];
					let _g15 = 0;
					while(_g15 < _this2.length) {
						let v = _this2[_g15];
						++_g15;
						let _g = v.type;
						if(_g._hx_index == 0 && _g.name == "Child") {
							_g14.push(v);
						}
					}
					let result1 = new Array(_g14.length);
					let _g16 = 0;
					let _g17 = _g14.length;
					while(_g16 < _g17) {
						let i = _g16++;
						let n = _g14[i];
						result1[i] = new boxup_cli_ChildDefinition(n.getProperty("name"),n.getProperty("symbol"),n.getProperty("required","false") == "true",n.getProperty("multiple","true") == "true");
					}
					blocks.push(new boxup_cli_BlockDefinition("@root",null,null,result1,[]));
					break;
				default:
				}
			}
		}
		return boxup_Result.Ok(new boxup_cli_Definition(id,blocks,meta));
	}
}
boxup_cli_DefinitionGenerator.__name__ = true;
class boxup_cli_DefinitionIdResolverCollection {
	static resolveDefinitionId(this1,nodes,source) {
		let _g = 0;
		while(_g < this1.length) {
			let _g1 = this1[_g++].resolveDefinitionId(nodes,source);
			switch(_g1._hx_index) {
			case 0:
				return haxe_ds_Option.Some(_g1.v);
			case 1:
				break;
			}
		}
		return haxe_ds_Option.None;
	}
}
class boxup_cli_DefinitionManager {
	constructor(resolver) {
		this.definitions = new haxe_ds_StringMap();
		this.resolver = resolver;
	}
	addDefinition(definition) {
		this.definitions.h[definition.id] = definition;
	}
	findDefinition(nodes,source) {
		let _g = boxup_cli_DefinitionIdResolverCollection.resolveDefinitionId(this.resolver,nodes,source);
		switch(_g._hx_index) {
		case 0:
			return this.getDefinition(_g.v);
		case 1:
			return haxe_ds_Option.None;
		}
	}
	getDefinition(id) {
		if(Object.prototype.hasOwnProperty.call(this.definitions.h,id)) {
			return haxe_ds_Option.Some(this.definitions.h[id]);
		}
		return haxe_ds_Option.None;
	}
	validate(nodes,source) {
		let _g = this.findDefinition(nodes,source);
		switch(_g._hx_index) {
		case 0:
			return _g.v.validate(nodes,source);
		case 1:
			return boxup_Result.Ok(nodes);
		}
	}
}
boxup_cli_DefinitionManager.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
class boxup_cli_GeneratorFactory {
	constructor(manager,factory) {
		this.generators = new haxe_ds_StringMap();
		this.manager = manager;
		this.factory = factory;
	}
	generate(nodes,source) {
		let _g = this.getGenerator(nodes,source);
		switch(_g._hx_index) {
		case 0:
			return _g.v.generate(nodes,source);
		case 1:
			return boxup_Result.Fail([new boxup_Error("Could not find a definition for " + source.filename,nodes[0].pos)]);
		}
	}
	getGenerator(nodes,source) {
		let _g = boxup_cli_DefinitionIdResolverCollection.resolveDefinitionId(this.manager.resolver,nodes,source);
		if(_g._hx_index == 0) {
			let _g1 = _g.v;
			if(!Object.prototype.hasOwnProperty.call(this.generators.h,_g1)) {
				let _g = this.manager.getDefinition(_g1);
				if(_g._hx_index == 0) {
					let this1 = this.generators;
					let value = this.factory(_g.v);
					this1.h[_g1] = value;
				}
			}
			let generator = this.generators.h[_g1];
			if(generator != null) {
				return haxe_ds_Option.Some(generator);
			} else {
				return haxe_ds_Option.None;
			}
		} else {
			return haxe_ds_Option.None;
		}
	}
}
boxup_cli_GeneratorFactory.__name__ = true;
class boxup_cli_Task {
	constructor(context,source,destination,generator,filter,extension) {
		this.context = context;
		this.source = source;
		this.destination = destination;
		this.generator = generator;
		this.filter = filter;
		this.extension = extension;
	}
}
boxup_cli_Task.__name__ = true;
class boxup_cli_TaskRunnerStream extends boxup_AbstractStream {
	constructor() {
		super();
	}
	write(chunk) {
		let _gthis = this;
		let result = chunk.result;
		switch(result._hx_index) {
		case 0:
			let task = result.data;
			let loader = new boxup_cli_loader_DirectoryLoader(task.source);
			let scanner = new boxup_ScannerStream();
			scanner.map(new boxup_cli_nodes_FilteredNodeStream(task.context.definitions,task.filter)).map(new boxup_ValidatorStream(task.context.definitions)).map(new boxup_GeneratorStream(task.generator)).pipe(new boxup_WriteStream(function(chunk) {
				let result = chunk.result;
				let data;
				switch(result._hx_index) {
				case 0:
					data = boxup_Result.Ok({ task : task, content : result.data});
					break;
				case 1:
					data = boxup_Result.Fail(result.error);
					break;
				}
				let data1 = { result : data, source : chunk.source};
				let this1 = _gthis.onData;
				let _g = 0;
				while(_g < this1.length) this1[_g++](data1);
			}));
			loader.pipe(scanner);
			loader.load();
			break;
		case 1:
			break;
		}
		let result1 = chunk.result;
		switch(result1._hx_index) {
		case 0:
			break;
		case 1:
			let data = { result : boxup_Result.Fail(result1.error), source : chunk.source};
			let this1 = _gthis.onData;
			let _g = 0;
			while(_g < this1.length) this1[_g++](data);
			break;
		}
	}
}
boxup_cli_TaskRunnerStream.__name__ = true;
class boxup_cli_TaskStream extends boxup_AbstractStream {
	constructor(generators) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(generators);
	}
	_hx_constructor(generators) {
		this.generators = generators;
		super._hx_constructor();
	}
	write(chunk) {
		let result = chunk.result;
		switch(result._hx_index) {
		case 0:
			let _g = result.data;
			let _g1 = 0;
			let _g2 = _g.config.tasks;
			while(_g1 < _g2.length) {
				let task = _g2[_g1];
				++_g1;
				let this1 = this.onData;
				let data = { result : boxup_Result.Ok(new boxup_cli_Task(_g,task.source,task.destination,new boxup_cli_GeneratorFactory(_g.definitions,this.generators.h[task.generator]),task.filter,task.extension)), source : chunk.source};
				let _g3 = 0;
				while(_g3 < this1.length) this1[_g3++](data);
			}
			break;
		case 1:
			break;
		}
		let result1 = chunk.result;
		switch(result1._hx_index) {
		case 0:
			break;
		case 1:
			let data = { result : boxup_Result.Fail(result1.error), source : chunk.source};
			let this1 = this.onData;
			let _g3 = 0;
			while(_g3 < this1.length) this1[_g3++](data);
			break;
		}
	}
}
boxup_cli_TaskStream.__name__ = true;
class boxup_cli_generator_HtmlGenerator {
	constructor(definition) {
		this.indent = 0;
		this.definition = definition;
	}
	generate(nodes,source) {
		this.indent = 0;
		return boxup_Result.Ok(this.wrap(nodes));
	}
	wrap(nodes) {
		let _gthis = this;
		return ["<!doctype HTML>",this.el("html",new haxe_ds_StringMap(),function() {
			return [_gthis.el("head",new haxe_ds_StringMap(),_gthis.generateHead(nodes)),_gthis.el("body",new haxe_ds_StringMap(),_gthis.generateNodes(nodes))];
		})].join("\n");
	}
	generateHead(nodes) {
		let prefix = this.definition.getMeta("html.documentTitlePrefix");
		let css = this.definition.getMeta("html.documentStyles");
		let title = "Boxup Document";
		let _gthis = this;
		let _g = 0;
		while(_g < nodes.length) {
			let node = nodes[_g];
			++_g;
			let _g1 = node.type;
			if(_g1._hx_index == 0) {
				let def = this.definition.getBlock(_g1.name);
				if(def != null) {
					let prop = def.getMeta("html.setDocumentTitle");
					if(prop != null) {
						title = node.getProperty(prop,"Boxup Document");
						break;
					}
				}
			}
		}
		if(prefix != null) {
			title = "" + prefix + " | " + title;
		}
		return function() {
			let _this = _gthis.el("title",new haxe_ds_StringMap(),function() {
				return [title];
			},{ noIndent : true});
			let _this1;
			if(css != null) {
				let _gthis1 = _gthis;
				let _g = new haxe_ds_StringMap();
				_g.h["rel"] = "stylesheet";
				_g.h["href"] = css;
				_this1 = _gthis1.el("link",_g);
			} else {
				_this1 = null;
			}
			let _this2 = [_this,_this1];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this2.length) {
				let v = _this2[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			return _g;
		};
	}
	generateNode(node,wrapParagraph) {
		if(wrapParagraph == null) {
			wrapParagraph = true;
		}
		let _g = node.type;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.name;
			switch(_g1) {
			case "@bold":
				return this.el("b",new haxe_ds_StringMap(),this.generateNodes(node.children),{ noIndent : true});
			case "@italic":
				return this.el("i",new haxe_ds_StringMap(),this.generateNodes(node.children),{ noIndent : true});
			case "@raw":
				return this.el("pre",new haxe_ds_StringMap(),this.generateNodes(node.children),{ noIndent : true});
			default:
				let def = this.definition.getBlock(_g1);
				let hint = def == null ? "Section" : def.getMeta("html.renderHint","Section");
				if(hint == null) {
					let _g = new haxe_ds_StringMap();
					let value = this.generateClassName(_g1,node);
					_g.h["class"] = value;
					return this.el("div",_g,this.generateNodes(node.children));
				} else {
					switch(hint) {
					case "Header":
						let _g2 = new haxe_ds_StringMap();
						let value = this.generateClassName(_g1,node);
						_g2.h["class"] = value;
						return this.el("h1",_g2,this.generateNodes(node.children,false),{ noIndent : true});
					case "Image":
						let _g3 = new haxe_ds_StringMap();
						let value1 = node.getProperty("src");
						_g3.h["src"] = value1;
						let value2 = node.getProperty("alt");
						_g3.h["alt"] = value2;
						return this.el("img",_g3);
					case "Link":
						let _g4 = new haxe_ds_StringMap();
						let value3 = node.getProperty("href");
						_g4.h["href"] = value3;
						return this.el("a",_g4,this.generateNodes(node.children,false),{ noIndent : true});
					case "ListContainer":
						let _g5 = new haxe_ds_StringMap();
						let value4 = this.generateClassName(_g1,node);
						_g5.h["class"] = value4;
						return this.el("ul",_g5,this.generateNodes(node.children));
					case "ListItem":
						let _g6 = new haxe_ds_StringMap();
						let value5 = this.generateClassName(_g1,node);
						_g6.h["class"] = value5;
						return this.el("li",_g6,this.generateNodes(node.children,false));
					case "None":
						return null;
					case "SubHeader":
						let _g7 = new haxe_ds_StringMap();
						let value6 = this.generateClassName(_g1,node);
						_g7.h["class"] = value6;
						return this.el("h2",_g7,this.generateNodes(node.children,false),{ noIndent : true});
					case "Template":
						let children = this.generateNodes(node.children,def.getMeta("html.wrapParagraph") != "false");
						let template = new haxe_Template(def.getMeta("html.template","::children::"));
						let context = { };
						this.addIndent();
						let _g8 = 0;
						let _g9 = node.properties;
						while(_g8 < _g9.length) {
							let prop = _g9[_g8];
							++_g8;
							context[prop.name] = prop.value.value;
						}
						context["__indent__"] = this.getPadding();
						context["children"] = this.fragment(children);
						this.removeIndent();
						return template.execute(context);
					default:
						let _g10 = new haxe_ds_StringMap();
						let value7 = this.generateClassName(_g1,node);
						_g10.h["class"] = value7;
						return this.el("div",_g10,this.generateNodes(node.children));
					}
				}
			}
			break;
		case 1:
			if(wrapParagraph) {
				return this.el("p",new haxe_ds_StringMap(),this.generateNodes(node.children),{ noIndent : true});
			} else {
				let _this = node.children;
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = this.generateNode(_this[i],false);
				}
				return result.join("");
			}
			break;
		case 2:
			return StringTools.htmlEscape(node.textContent);
		}
	}
	generateClassName(name,node) {
		let def = this.definition.getBlock(name);
		let className = name.toLowerCase();
		if(def == null) {
			return className;
		}
		let idProperty = def.getIdProperty();
		if(idProperty == null) {
			return className;
		}
		let _g = node.getProperty(idProperty);
		if(_g == null) {
			return className;
		} else {
			return "" + className + " " + className + "--" + StringTools.replace(StringTools.htmlEscape(_g.toLowerCase())," ","-");
		}
	}
	generateNodes(nodes,wrapParagraph) {
		if(wrapParagraph == null) {
			wrapParagraph = true;
		}
		let _gthis = this;
		return function() {
			let result = new Array(nodes.length);
			let _g = 0;
			let _g1 = nodes.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _gthis.generateNode(nodes[i],wrapParagraph);
			}
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < result.length) {
				let v = result[_g3];
				++_g3;
				if(v != null) {
					_g2.push(v);
				}
			}
			return _g2;
		};
	}
	fragment(children) {
		let _g = [];
		let _this = children();
		let _g1_current = 0;
		while(_g1_current < _this.length) {
			let _g2_value = _this[_g1_current];
			if(_g1_current++ != 0) {
				_g.push(this.getPadding() + _g2_value);
			} else {
				_g.push(_g2_value);
			}
		}
		return _g.join("\n");
	}
	el(tag,props,children,options) {
		if(options == null) {
			options = { noIndent : false};
		}
		let out = "<" + tag;
		let _g = [];
		let h = props.h;
		let _g1_keys = Object.keys(h);
		let _g1_length = _g1_keys.length;
		let _g1_current = 0;
		while(_g1_current < _g1_length) {
			let key = _g1_keys[_g1_current++];
			let _g2_value = h[key];
			if(_g2_value != null) {
				_g.push("" + key + "=\"" + _g2_value + "\"");
			} else {
				_g.push(null);
			}
		}
		let _g1 = [];
		let _g2 = 0;
		while(_g2 < _g.length) {
			let v = _g[_g2];
			++_g2;
			if(v != null) {
				_g1.push(v);
			}
		}
		if(_g1.length > 0) {
			out += " " + _g1.join(" ");
		}
		if(children != null && options.noIndent) {
			return out + (">" + children().join("") + "</" + tag + ">");
		} else if(children != null) {
			this.addIndent();
			let _this = children();
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = this.getPadding() + _this[i];
			}
			let result1 = result.join("\n");
			this.removeIndent();
			return out + ">\n" + result1 + ("\n" + this.getPadding() + "</" + tag + ">");
		} else {
			return out + "/>";
		}
	}
	addIndent() {
		this.indent++;
	}
	removeIndent() {
		this.indent--;
		if(this.indent < 0) {
			this.indent = 0;
		}
	}
	getPadding() {
		if(this.indent == 0) {
			return "";
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.indent;
		while(_g1 < _g2) {
			++_g1;
			_g.push("  ");
		}
		return _g.join("");
	}
}
boxup_cli_generator_HtmlGenerator.__name__ = true;
class boxup_cli_generator_MarkdownGenerator {
	constructor(definition) {
		this.definition = definition;
	}
	generate(nodes,source) {
		return boxup_Result.Ok(this.fragment(nodes));
	}
	generateNodes(nodes) {
		let f = $bind(this,this.generateNode);
		let result = new Array(nodes.length);
		let _g = 0;
		let _g1 = nodes.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(nodes[i]);
		}
		return result;
	}
	generateNode(node) {
		let _g = node.type;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.name;
			switch(_g1) {
			case "@bold":
				return "**" + this.fragment(node.children) + "**";
			case "@italic":
				return "_" + this.fragment(node.children) + "_";
			case "@raw":
				return "`" + this.fragment(node.children) + "`";
			default:
				let def = this.definition.getBlock(_g1);
				let hint = def == null ? "Fragment" : def.getMeta("md.renderHint","Fragment");
				if(hint == null) {
					return this.fragment(node.children);
				} else {
					switch(hint) {
					case "Header":
						return "# " + this.fragment(node.children);
					case "Link":
						return "[" + this.fragment(node.children) + "](" + node.getProperty("href") + ")";
					case "ListContainer":
						return "\n" + this.fragment(node.children);
					case "ListItem":
						return "- " + this.fragment(node.children);
					case "SubHeader":
						return "## " + this.fragment(node.children);
					case "Template":
						let template = new haxe_Template(def.getMeta("md.template","::children::"));
						let context = { };
						let _g2 = 0;
						let _g3 = node.properties;
						while(_g2 < _g3.length) {
							let prop = _g3[_g2];
							++_g2;
							context[prop.name] = prop.value.value;
						}
						context["children"] = this.fragment(node.children);
						return template.execute(context);
					default:
						return this.fragment(node.children);
					}
				}
			}
			break;
		case 1:
			return this.fragment(node.children,true);
		case 2:
			return node.textContent;
		}
	}
	fragment(nodes,isInline) {
		if(isInline == null) {
			isInline = false;
		}
		return this.generateNodes(nodes).join(isInline ? "" : "\n");
	}
}
boxup_cli_generator_MarkdownGenerator.__name__ = true;
class boxup_cli_loader_DirectoryLoader extends boxup_ReadStream {
	constructor(root) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(root);
	}
	_hx_constructor(root) {
		this.root = root;
		super._hx_constructor();
	}
	load() {
		let data = this.readDir(this.root);
		let item = data.pop();
		while(item != null) {
			let this1 = this.onData;
			let data1 = boxup_Result.Ok(item);
			let _g = 0;
			while(_g < this1.length) this1[_g++](data1);
			item = data.pop();
		}
		this.close();
	}
	readDir(path) {
		let out = [];
		let _g = 0;
		let _g1 = js_node_Fs.readdirSync(path);
		while(_g < _g1.length) {
			let name = _g1[_g];
			++_g;
			if(haxe_io_Path.extension(name) == "box") {
				let filename = haxe_io_Path.join([path,name]);
				out.push(new boxup_Source(filename,js_node_Fs.readFileSync(filename,{ encoding : "utf8"})));
			} else {
				let filename = haxe_io_Path.join([path,name]);
				if(sys_FileSystem.isDirectory(filename)) {
					out = out.concat(this.readDir(filename));
				}
			}
		}
		return out;
	}
}
boxup_cli_loader_DirectoryLoader.__name__ = true;
class boxup_cli_nodes_FilteredNodeStream extends boxup_AbstractStream {
	constructor(manager,allowedIds) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(manager,allowedIds);
	}
	_hx_constructor(manager,allowedIds) {
		this.manager = manager;
		this.allowedIds = allowedIds;
		super._hx_constructor();
	}
	write(chunk) {
		let result = chunk.result;
		let result1;
		switch(result._hx_index) {
		case 0:
			result1 = new boxup_Parser(result.data).parse();
			break;
		case 1:
			result1 = boxup_Result.Fail(result.error);
			break;
		}
		switch(result1._hx_index) {
		case 0:
			let _g = result1.data;
			let _g1 = boxup_cli_DefinitionIdResolverCollection.resolveDefinitionId(this.manager.resolver,_g,chunk.source);
			switch(_g1._hx_index) {
			case 0:
				if(!(!this.allowedIds.includes(_g1.v) && !this.allowedIds.includes("*"))) {
					let data = { result : boxup_Result.Ok(_g), source : chunk.source};
					let this1 = this.onData;
					let _g1 = 0;
					while(_g1 < this1.length) this1[_g1++](data);
				}
				break;
			case 1:
				if(this.allowedIds.includes("*")) {
					let data = { result : boxup_Result.Ok(_g), source : chunk.source};
					let this1 = this.onData;
					let _g1 = 0;
					while(_g1 < this1.length) this1[_g1++](data);
				}
				break;
			default:
				let data = { result : boxup_Result.Ok(_g), source : chunk.source};
				let this1 = this.onData;
				let _g2 = 0;
				while(_g2 < this1.length) this1[_g2++](data);
			}
			break;
		case 1:
			break;
		}
		let result2 = result1;
		switch(result2._hx_index) {
		case 0:
			break;
		case 1:
			let data1 = { result : boxup_Result.Fail(result2.error), source : chunk.source};
			let this2 = this.onData;
			let _g3 = 0;
			while(_g3 < this2.length) this2[_g3++](data1);
			break;
		}
	}
}
boxup_cli_nodes_FilteredNodeStream.__name__ = true;
class boxup_cli_resolver_FileNameResolver {
	constructor() {
	}
	resolveDefinitionId(nodes,source) {
		let _g = haxe_io_Path.withoutDirectory(source.filename).split(".");
		if(_g.length == 3) {
			if(_g[2] == "box") {
				return haxe_ds_Option.Some(_g[1]);
			} else {
				return haxe_ds_Option.None;
			}
		} else {
			return haxe_ds_Option.None;
		}
	}
}
boxup_cli_resolver_FileNameResolver.__name__ = true;
class boxup_cli_writer_FileWriter extends boxup_WriteStream {
	constructor() {
		boxup_WriteStream._hx_skip_constructor = true;
		super();
		boxup_WriteStream._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		let _gthis = this;
		super._hx_constructor(function(chunk) {
			_gthis.handleChunk(chunk.result,chunk.source);
		});
	}
	handleChunk(content,source) {
		switch(content._hx_index) {
		case 0:
			let _g = content.data;
			let fullPath = haxe_io_Path.join([_g.task.destination,this.getDestName(source.filename,_g.task.extension)]);
			let dir = haxe_io_Path.directory(fullPath);
			if(!sys_FileSystem.exists(dir)) {
				sys_FileSystem.createDirectory(dir);
			}
			if(!sys_FileSystem.isDirectory(dir)) {
				throw haxe_Exception.thrown("Not a directiory: " + dir);
			}
			js_node_Fs.writeFileSync(fullPath,_g.content);
			break;
		case 1:
			break;
		}
	}
	getDestName(filename,extension) {
		let _g = haxe_io_Path.withoutDirectory(filename).split(".");
		if(_g.length == 3) {
			if(_g[2] == "box") {
				return haxe_io_Path.withExtension(_g[0],extension);
			} else {
				return haxe_io_Path.withExtension(filename,extension);
			}
		} else {
			return haxe_io_Path.withExtension(filename,extension);
		}
	}
}
boxup_cli_writer_FileWriter.__name__ = true;
class boxup_ls_Worklet {
	constructor(reporter,controller,reader) {
		let _g = new haxe_ds_StringMap();
		_g.h["html"] = function(definition) {
			return new boxup_cli_generator_HtmlGenerator(definition);
		};
		_g.h["md"] = function(definition) {
			return new boxup_cli_generator_MarkdownGenerator(definition);
		};
		this.generators = _g;
		this.reporter = reporter;
		this.controller = controller;
		this.reader = reader;
	}
	register(context) {
		let reset = this.run();
		let _gthis = this;
		Vscode.workspace.onDidChangeTextDocument(function(change) {
			if(boxup_ls_core_Util.isBoxConfig(change.document) || boxup_ls_core_Util.isDefinitionDocument(change.document)) {
				reset();
				reset = _gthis.run();
			}
		});
	}
	run() {
		let configLoader = new boxup_ls_loader_WorkspaceBoxConfigLoader();
		let _g = [];
		let key_keys = Object.keys(this.generators.h);
		let key_length = key_keys.length;
		let key_current = 0;
		while(key_current < key_length) _g.push(key_keys[key_current++]);
		let config = new boxup_cli_ConfigStream(_g);
		config.map(new boxup_cli_ContextStream([new boxup_cli_resolver_FileNameResolver()])).map(new boxup_ls_command_CommandStream(this.controller,this.generators,this.reporter)).pipe(new boxup_ls_diagnostic_DiagnosticStream(this.reporter,this.reader));
		configLoader.pipe(config);
		configLoader.load();
		return $bind(configLoader,configLoader.close);
	}
}
boxup_ls_Worklet.__name__ = true;
class boxup_ls_command_CommandStream extends boxup_AbstractStream {
	constructor(controller,generators,reporter) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(controller,generators,reporter);
	}
	_hx_constructor(controller,generators,reporter) {
		this.controller = controller;
		this.generators = generators;
		this.reporter = reporter;
		super._hx_constructor();
	}
	write(chunk) {
		let _gthis = this;
		let this1 = this.controller.onCompile;
		let listener = function(_) {
			_gthis.compile(chunk);
		};
		this1.push(listener);
		let cancel = function() {
			HxOverrides.remove(this1,listener);
		};
		let listener1 = function(_) {
			cancel();
		};
		this.onClose.push(listener1);
		let this2 = this.onData;
		let _g = 0;
		while(_g < this2.length) this2[_g++](chunk);
	}
	compile(chunk) {
		if(!this.isWritable()) {
			return;
		}
		let tasks = new boxup_cli_TaskStream(this.generators);
		let writer = new boxup_cli_writer_FileWriter();
		tasks.map(new boxup_cli_TaskRunnerStream()).map(new boxup_ReporterStream(this.reporter)).pipe(writer);
		tasks.write(chunk);
		tasks.end();
	}
}
boxup_ls_command_CommandStream.__name__ = true;
class boxup_ls_command_Controller {
	constructor() {
		this.onCompile = [];
	}
	register(context) {
		let _gthis = this;
		context.subscriptions.push(Vscode.commands.registerCommand("box.compile",function() {
			let this1 = _gthis.onCompile;
			let _g = 0;
			while(_g < this1.length) this1[_g++](_gthis);
		}));
	}
}
boxup_ls_command_Controller.__name__ = true;
class boxup_ls_core_Util {
	static isBoxConfig(document) {
		return haxe_io_Path.withoutDirectory(document.fileName) == ".boxconfig";
	}
	static getEditorByUri(uri) {
		return Lambda.find(Vscode.window.visibleTextEditors,function(editor) {
			return editor.document.uri.toString() == uri.toString();
		});
	}
	static isBoxupDocument(document) {
		return document.languageId == "box";
	}
	static isDefinitionDocument(document) {
		if(!boxup_ls_core_Util.isBoxupDocument(document)) {
			return false;
		}
		let _g = haxe_io_Path.withoutDirectory(document.fileName).split(".");
		if(_g.length == 3) {
			if(_g[1] == "d") {
				if(_g[2] == "box") {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}
boxup_ls_core_Util.__name__ = true;
class boxup_ls_diagnostic_DiagnosticReporter {
	constructor() {
		this.collection = Vscode.languages.createDiagnosticCollection("boxup");
	}
	register(context) {
		let _gthis = this;
		context.subscriptions.push(this.collection);
		Vscode.workspace.onDidChangeTextDocument(function(change) {
			if(boxup_ls_core_Util.isBoxupDocument(change.document)) {
				_gthis.clear(change.document.uri);
			}
		});
		Vscode.workspace.onDidCloseTextDocument(function(document) {
			if(boxup_ls_core_Util.isBoxupDocument(document)) {
				_gthis.remove(document.uri);
			}
		});
	}
	clear(uri) {
		this.collection.set(uri,[]);
	}
	remove(uri) {
		this.collection.delete(uri);
	}
	report(errors,source) {
		this.collection.clear();
		let diags_h = Object.create(null);
		let _g = 0;
		let _g1 = errors;
		while(_g < _g1.length) {
			let error = _g1[_g];
			++_g;
			console.log("src/boxup/ls/diagnostic/DiagnosticReporter.hx:47:",error.toString());
			if(error.pos.file.startsWith("<")) {
				Vscode.window.showErrorMessage(error.toString());
				return;
			}
			let uri = vscode_Uri.file(error.pos.file);
			let path = uri.toString();
			let editor = boxup_ls_core_Util.getEditorByUri(uri);
			if(editor == null) {
				return;
			}
			let source = editor.document.getText();
			let pos = error.pos;
			let startLine = 0;
			let endLine = 0;
			let charPos = 0;
			let startChar = 0;
			let endChar = 0;
			while(charPos <= pos.min) {
				++charPos;
				++startChar;
				if(source.charAt(charPos) == "\n") {
					++startLine;
					startChar = -2;
				}
			}
			endLine = startLine;
			endChar = startChar;
			while(charPos <= pos.max) {
				++charPos;
				++endChar;
				if(source.charAt(charPos) == "\n") {
					++endLine;
					endChar = 0;
				}
			}
			let diag = new vscode_Diagnostic(new vscode_Range(startLine,startChar,endLine,endChar),error.message,vscode_DiagnosticSeverity.Error);
			if(!Object.prototype.hasOwnProperty.call(diags_h,path)) {
				diags_h[path] = [];
			}
			diags_h[path].push(diag);
		}
		let _g2_keys = Object.keys(diags_h);
		let _g2_length = _g2_keys.length;
		let _g2_current = 0;
		while(_g2_current < _g2_length) {
			let key = _g2_keys[_g2_current++];
			let _g3_value = diags_h[key];
			this.collection.set(vscode_Uri.parse(key),_g3_value);
		}
	}
}
boxup_ls_diagnostic_DiagnosticReporter.__name__ = true;
class boxup_ls_diagnostic_DiagnosticStream extends boxup_AbstractStream {
	constructor(reporter,reader) {
		boxup_ReadStream._hx_skip_constructor = true;
		super();
		boxup_ReadStream._hx_skip_constructor = false;
		this._hx_constructor(reporter,reader);
	}
	_hx_constructor(reporter,reader) {
		this.reporter = reporter;
		this.reader = reader;
		super._hx_constructor();
	}
	write(chunk) {
		let _gthis = this;
		let result = chunk.result;
		switch(result._hx_index) {
		case 0:
			let scanner = new boxup_ScannerStream();
			scanner.map(new boxup_ParserStream()).map(new boxup_ValidatorStream(result.data.definitions)).map(new boxup_ReporterStream(_gthis.reporter)).pipe(new boxup_WriteStream(function(_) {
				let this1 = _gthis.onData;
				let _g = 0;
				while(_g < this1.length) this1[_g++](chunk);
			}));
			let listener = function(_) {
				scanner.end();
			};
			_gthis.onClose.push(listener);
			_gthis.reader.pipe(scanner);
			break;
		case 1:
			break;
		}
		let result1 = chunk.result;
		switch(result1._hx_index) {
		case 0:
			break;
		case 1:
			_gthis.reporter.report(result1.error,chunk.source);
			let this1 = _gthis.onData;
			let _g = 0;
			while(_g < this1.length) this1[_g++](chunk);
			break;
		}
	}
}
boxup_ls_diagnostic_DiagnosticStream.__name__ = true;
class boxup_ls_loader_TextDocumentLoader extends boxup_ReadStream {
	constructor() {
		super();
	}
	register(context) {
		let _gthis = this;
		Vscode.workspace.onDidChangeTextDocument(function(change) {
			if(boxup_ls_core_Util.isBoxupDocument(change.document)) {
				_gthis.send(change.document);
			}
		});
		Vscode.window.onDidChangeActiveTextEditor(function(change) {
			if(boxup_ls_core_Util.isBoxupDocument(change.document)) {
				_gthis.send(change.document);
			}
		});
	}
	send(doc) {
		let source = new boxup_Source(doc.uri.fsPath,doc.getText());
		if(this.isReadable()) {
			let this1 = this.onData;
			let data = boxup_Result.Ok(source);
			let _g = 0;
			while(_g < this1.length) this1[_g++](data);
		}
	}
}
boxup_ls_loader_TextDocumentLoader.__name__ = true;
class boxup_ls_loader_WorkspaceBoxConfigLoader extends boxup_ReadStream {
	constructor() {
		super();
	}
	load() {
		let _gthis = this;
		Vscode.workspace.findFiles(".boxconfig").then(function(uris) {
			if(uris.length == 0) {
				if(_gthis.isReadable()) {
					let this1 = _gthis.onData;
					let data = boxup_Result.Fail([new boxup_Error("Cound not find a .boxconfig file",new boxup_Position(0,0,"<unknown>"))]);
					let _g = 0;
					while(_g < this1.length) this1[_g++](data);
				}
				return;
			}
			let _g = 0;
			while(_g < uris.length) {
				let uri = uris[_g];
				++_g;
				Vscode.workspace.fs.readFile(uri).then(function(bytes) {
					let _g = [];
					let _g1 = 0;
					while(_g1 < bytes.length) {
						let b = bytes[_g1++];
						_g.push(String.fromCodePoint(b));
					}
					let content = _g.join("");
					let source = new boxup_Source(uri.fsPath,content);
					if(_gthis.isReadable()) {
						let this1 = _gthis.onData;
						let data = boxup_Result.Ok(source);
						let _g = 0;
						while(_g < this1.length) this1[_g++](data);
					}
				});
			}
		},function(err) {
			throw haxe_Exception.thrown(err);
		});
	}
}
boxup_ls_loader_WorkspaceBoxConfigLoader.__name__ = true;
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:true,__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
class haxe_CallStack {
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g++];
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) if(haxe_CallStack.equalItems(this1[i],stack[_g++])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1._hx_index) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 1) {
					return item1.m == item2.m;
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 2) {
					if(item1.file == item2.file && item1.line == item2.line && item1.column == item2.column) {
						return haxe_CallStack.equalItems(item1.s,item2.s);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 3) {
					if(item1.classname == item2.classname) {
						return item1.method == item2.method;
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 4) {
					return item1.v == item2.v;
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let _g = s.m;
			b.b = (b.b += "module ") + (_g == null ? "null" : "" + _g);
			break;
		case 2:
			let _g1 = s.s;
			let _g2 = s.file;
			let _g3 = s.line;
			let _g4 = s.column;
			if(_g1 != null) {
				haxe_CallStack.itemToString(b,_g1);
				b.b += " (";
			}
			b.b = (b.b += _g2 == null ? "null" : "" + _g2) + " line ";
			b.b += _g3 == null ? "null" : "" + _g3;
			if(_g4 != null) {
				b.b = (b.b += " column ") + (_g4 == null ? "null" : "" + _g4);
			}
			if(_g1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let _g5 = s.classname;
			let _g6 = s.method;
			b.b = (b.b += Std.string(_g5 == null ? "<unknown>" : _g5)) + ".";
			b.b += _g6 == null ? "null" : "" + _g6;
			break;
		case 4:
			let _g7 = s.v;
			b.b = (b.b += "local function #") + (_g7 == null ? "null" : "" + _g7);
			break;
		}
	}
}
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
		this.__skipStack = 0;
		let old = Error.prepareStackTrace;
		Error.prepareStackTrace = function(e) { return e.stack; }
		if(((native) instanceof Error)) {
			this.stack = native.stack;
		} else {
			let e = null;
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this,haxe_Exception);
				e = this;
			} else {
				e = new Error();
				if(typeof(e.stack) == "undefined") {
					try { throw e; } catch(_) {}
					this.__skipStack++;
				}
			}
			this.stack = e.stack;
		}
		Error.prepareStackTrace = old;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	details() {
		if(this.get_previous() == null) {
			let tmp = "Exception: " + this.toString();
			let tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			let result = "";
			let e = this;
			let prev = null;
			while(e != null) {
				if(prev == null) {
					let result1 = "Exception: " + e.get_message();
					let tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					let prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	__shiftStack() {
		this.__skipStack++;
	}
	get_message() {
		return this.message;
	}
	get_previous() {
		return this.__previousException;
	}
	get_native() {
		return this.__nativeException;
	}
	get_stack() {
		let _g = this.__exceptionStack;
		if(_g == null) {
			let value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			return _g;
		}
	}
	setProperty(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			e.__skipStack++;
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
Object.assign(haxe_Exception.prototype, {
	__properties__: {get_native: "get_native",get_previous: "get_previous",get_stack: "get_stack",get_message: "get_message"}
});
class haxe_NativeStackTrace {
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		while(true) if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				skip = --skip;
				pos += 1;
				continue;
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = true;
var haxe__$Template_TemplateExpr = $hxEnums["haxe._Template.TemplateExpr"] = { __ename__:true,__constructs__:null
	,OpVar: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpVar",$_.__params__ = ["v"],$_)
	,OpExpr: ($_=function(expr) { return {_hx_index:1,expr:expr,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpExpr",$_.__params__ = ["expr"],$_)
	,OpIf: ($_=function(expr,eif,eelse) { return {_hx_index:2,expr:expr,eif:eif,eelse:eelse,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpIf",$_.__params__ = ["expr","eif","eelse"],$_)
	,OpStr: ($_=function(str) { return {_hx_index:3,str:str,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpStr",$_.__params__ = ["str"],$_)
	,OpBlock: ($_=function(l) { return {_hx_index:4,l:l,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpBlock",$_.__params__ = ["l"],$_)
	,OpForeach: ($_=function(expr,loop) { return {_hx_index:5,expr:expr,loop:loop,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpForeach",$_.__params__ = ["expr","loop"],$_)
	,OpMacro: ($_=function(name,params) { return {_hx_index:6,name:name,params:params,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_._hx_name="OpMacro",$_.__params__ = ["name","params"],$_)
};
haxe__$Template_TemplateExpr.__constructs__ = [haxe__$Template_TemplateExpr.OpVar,haxe__$Template_TemplateExpr.OpExpr,haxe__$Template_TemplateExpr.OpIf,haxe__$Template_TemplateExpr.OpStr,haxe__$Template_TemplateExpr.OpBlock,haxe__$Template_TemplateExpr.OpForeach,haxe__$Template_TemplateExpr.OpMacro];
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class haxe_Template {
	constructor(str) {
		let tokens = this.parseTokens(str);
		this.expr = this.parseBlock(tokens);
		if(!tokens.isEmpty()) {
			throw haxe_Exception.thrown("Unexpected '" + Std.string(tokens.first().s) + "'");
		}
	}
	execute(context,macros) {
		this.macros = macros == null ? { } : macros;
		this.context = context;
		this.stack = new haxe_ds_List();
		this.buf = new StringBuf();
		this.run(this.expr);
		return this.buf.b;
	}
	resolve(v) {
		if(v == "__current__") {
			return this.context;
		}
		if(Reflect.isObject(this.context)) {
			let value = Reflect.getProperty(this.context,v);
			if(value != null || Object.prototype.hasOwnProperty.call(this.context,v)) {
				return value;
			}
		}
		let _g_head = this.stack.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			let value = Reflect.getProperty(val,v);
			if(value != null || Object.prototype.hasOwnProperty.call(val,v)) {
				return value;
			}
		}
		return Reflect.field(haxe_Template.globals,v);
	}
	parseTokens(data) {
		let tokens = new haxe_ds_List();
		while(haxe_Template.splitter.match(data)) {
			let p = haxe_Template.splitter.matchedPos();
			if(p.pos > 0) {
				tokens.add({ p : HxOverrides.substr(data,0,p.pos), s : true, l : null});
			}
			if(HxOverrides.cca(data,p.pos) == 58) {
				tokens.add({ p : HxOverrides.substr(data,p.pos + 2,p.len - 4), s : false, l : null});
				data = haxe_Template.splitter.matchedRight();
				continue;
			}
			let parp = p.pos + p.len;
			let npar = 1;
			let params = [];
			let part = "";
			while(true) {
				let c = HxOverrides.cca(data,parp);
				++parp;
				if(c == 40) {
					++npar;
				} else if(c == 41) {
					--npar;
					if(npar <= 0) {
						break;
					}
				} else if(c == null) {
					throw haxe_Exception.thrown("Unclosed macro parenthesis");
				}
				if(c == 44 && npar == 1) {
					params.push(part);
					part = "";
				} else {
					part += String.fromCodePoint(c);
				}
			}
			params.push(part);
			tokens.add({ p : haxe_Template.splitter.matched(2), s : false, l : params});
			data = HxOverrides.substr(data,parp,data.length - parp);
		}
		if(data.length > 0) {
			tokens.add({ p : data, s : true, l : null});
		}
		return tokens;
	}
	parseBlock(tokens) {
		let l = new haxe_ds_List();
		while(true) {
			let t = tokens.first();
			if(t == null) {
				break;
			}
			if(!t.s && (t.p == "end" || t.p == "else" || HxOverrides.substr(t.p,0,7) == "elseif ")) {
				break;
			}
			l.add(this.parse(tokens));
		}
		if(l.length == 1) {
			return l.first();
		}
		return haxe__$Template_TemplateExpr.OpBlock(l);
	}
	parse(tokens) {
		let t = tokens.pop();
		let p = t.p;
		if(t.s) {
			return haxe__$Template_TemplateExpr.OpStr(p);
		}
		if(t.l != null) {
			let pe = new haxe_ds_List();
			let _g = 0;
			let _g1 = t.l;
			while(_g < _g1.length) pe.add(this.parseBlock(this.parseTokens(_g1[_g++])));
			return haxe__$Template_TemplateExpr.OpMacro(p,pe);
		}
		let kwdEnd = function(kwd) {
			let pos = -1;
			let length = kwd.length;
			if(HxOverrides.substr(p,0,length) == kwd) {
				pos = length;
				let s = HxOverrides.substr(p,length,null);
				let _g_offset = 0;
				while(_g_offset < s.length) if(s.charCodeAt(_g_offset++) == 32) {
					++pos;
				} else {
					break;
				}
			}
			return pos;
		};
		let pos = kwdEnd("if");
		if(pos > 0) {
			p = HxOverrides.substr(p,pos,p.length - pos);
			let e = this.parseExpr(p);
			let eif = this.parseBlock(tokens);
			let t = tokens.first();
			let eelse;
			if(t == null) {
				throw haxe_Exception.thrown("Unclosed 'if'");
			}
			if(t.p == "end") {
				tokens.pop();
				eelse = null;
			} else if(t.p == "else") {
				tokens.pop();
				eelse = this.parseBlock(tokens);
				t = tokens.pop();
				if(t == null || t.p != "end") {
					throw haxe_Exception.thrown("Unclosed 'else'");
				}
			} else {
				t.p = HxOverrides.substr(t.p,4,t.p.length - 4);
				eelse = this.parse(tokens);
			}
			return haxe__$Template_TemplateExpr.OpIf(e,eif,eelse);
		}
		let pos1 = kwdEnd("foreach");
		if(pos1 >= 0) {
			p = HxOverrides.substr(p,pos1,p.length - pos1);
			let e = this.parseExpr(p);
			let efor = this.parseBlock(tokens);
			let t = tokens.pop();
			if(t == null || t.p != "end") {
				throw haxe_Exception.thrown("Unclosed 'foreach'");
			}
			return haxe__$Template_TemplateExpr.OpForeach(e,efor);
		}
		if(haxe_Template.expr_splitter.match(p)) {
			return haxe__$Template_TemplateExpr.OpExpr(this.parseExpr(p));
		}
		return haxe__$Template_TemplateExpr.OpVar(p);
	}
	parseExpr(data) {
		let l = new haxe_ds_List();
		let expr = data;
		while(haxe_Template.expr_splitter.match(data)) {
			let p = haxe_Template.expr_splitter.matchedPos();
			if(p.pos != 0) {
				l.add({ p : HxOverrides.substr(data,0,p.pos), s : true});
			}
			let p1 = haxe_Template.expr_splitter.matched(0);
			l.add({ p : p1, s : p1.indexOf("\"") >= 0});
			data = haxe_Template.expr_splitter.matchedRight();
		}
		if(data.length != 0) {
			let _g_offset = 0;
			let _g_s = data;
			while(_g_offset < _g_s.length) {
				let _g1_key = _g_offset;
				if(_g_s.charCodeAt(_g_offset++) != 32) {
					l.add({ p : HxOverrides.substr(data,_g1_key,null), s : true});
					break;
				}
			}
		}
		let e;
		try {
			e = this.makeExpr(l);
			if(!l.isEmpty()) {
				throw haxe_Exception.thrown(l.first().p);
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				throw haxe_Exception.thrown("Unexpected '" + _g1 + "' in " + expr);
			} else {
				throw _g;
			}
		}
		return function() {
			try {
				return e();
			} catch( _g ) {
				throw haxe_Exception.thrown("Error : " + Std.string(haxe_Exception.caught(_g).unwrap()) + " in " + expr);
			}
		};
	}
	makeConst(v) {
		haxe_Template.expr_trim.match(v);
		v = haxe_Template.expr_trim.matched(1);
		if(HxOverrides.cca(v,0) == 34) {
			let str = HxOverrides.substr(v,1,v.length - 2);
			return function() {
				return str;
			};
		}
		if(haxe_Template.expr_int.match(v)) {
			let i = Std.parseInt(v);
			return function() {
				return i;
			};
		}
		if(haxe_Template.expr_float.match(v)) {
			let f = parseFloat(v);
			return function() {
				return f;
			};
		}
		let me = this;
		return function() {
			return me.resolve(v);
		};
	}
	makePath(e,l) {
		let p = l.first();
		if(p == null || p.p != ".") {
			return e;
		}
		l.pop();
		let field = l.pop();
		if(field == null || !field.s) {
			throw haxe_Exception.thrown(field.p);
		}
		let f = field.p;
		haxe_Template.expr_trim.match(f);
		f = haxe_Template.expr_trim.matched(1);
		return this.makePath(function() {
			return Reflect.field(e(),f);
		},l);
	}
	makeExpr(l) {
		return this.makePath(this.makeExpr2(l),l);
	}
	skipSpaces(l) {
		let p = l.first();
		while(p != null) {
			let s = p.p;
			let _g_offset = 0;
			while(_g_offset < s.length) if(s.charCodeAt(_g_offset++) != 32) {
				return;
			}
			l.pop();
			p = l.first();
		}
	}
	makeExpr2(l) {
		this.skipSpaces(l);
		let p = l.pop();
		this.skipSpaces(l);
		if(p == null) {
			throw haxe_Exception.thrown("<eof>");
		}
		if(p.s) {
			return this.makeConst(p.p);
		}
		switch(p.p) {
		case "!":
			let e = this.makeExpr(l);
			return function() {
				let v = e();
				if(v != null) {
					return v == false;
				} else {
					return true;
				}
			};
		case "(":
			this.skipSpaces(l);
			let e1 = this.makeExpr(l);
			this.skipSpaces(l);
			let p1 = l.pop();
			if(p1 == null || p1.s) {
				throw haxe_Exception.thrown(p1);
			}
			if(p1.p == ")") {
				return e1;
			}
			this.skipSpaces(l);
			let e2 = this.makeExpr(l);
			this.skipSpaces(l);
			let p2 = l.pop();
			this.skipSpaces(l);
			if(p2 == null || p2.p != ")") {
				throw haxe_Exception.thrown(p2);
			}
			switch(p1.p) {
			case "!=":
				return function() {
					return e1() != e2();
				};
			case "&&":
				return function() {
					return e1() && e2();
				};
			case "*":
				return function() {
					return e1() * e2();
				};
			case "+":
				return function() {
					return e1() + e2();
				};
			case "-":
				return function() {
					return e1() - e2();
				};
			case "/":
				return function() {
					return e1() / e2();
				};
			case "<":
				return function() {
					return e1() < e2();
				};
			case "<=":
				return function() {
					return e1() <= e2();
				};
			case "==":
				return function() {
					return e1() == e2();
				};
			case ">":
				return function() {
					return e1() > e2();
				};
			case ">=":
				return function() {
					return e1() >= e2();
				};
			case "||":
				return function() {
					return e1() || e2();
				};
			default:
				throw haxe_Exception.thrown("Unknown operation " + p1.p);
			}
			break;
		case "-":
			let e3 = this.makeExpr(l);
			return function() {
				return -e3();
			};
		}
		throw haxe_Exception.thrown(p.p);
	}
	run(e) {
		switch(e._hx_index) {
		case 0:
			let _this = this.buf;
			let x = Std.string(this.resolve(e.v));
			_this.b += Std.string(x);
			break;
		case 1:
			let _this1 = this.buf;
			let x1 = Std.string(e.expr());
			_this1.b += Std.string(x1);
			break;
		case 2:
			let _g = e.eelse;
			let v = e.expr();
			if(v == null || v == false) {
				if(_g != null) {
					this.run(_g);
				}
			} else {
				this.run(e.eif);
			}
			break;
		case 3:
			let _g1 = e.str;
			this.buf.b += _g1 == null ? "null" : "" + _g1;
			break;
		case 4:
			let _g_head = e.l.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				this.run(val);
			}
			break;
		case 5:
			let _g2 = e.loop;
			let v1 = e.expr();
			try {
				let x = $getIterator(v1);
				if(x.hasNext == null) {
					throw haxe_Exception.thrown(null);
				}
				v1 = x;
			} catch( _g ) {
				try {
					if(v1.hasNext == null) {
						throw haxe_Exception.thrown(null);
					}
				} catch( _g ) {
					throw haxe_Exception.thrown("Cannot iter on " + Std.string(v1));
				}
			}
			this.stack.push(this.context);
			let v2 = v1;
			while(v2.hasNext()) {
				this.context = v2.next();
				this.run(_g2);
			}
			this.context = this.stack.pop();
			break;
		case 6:
			let _g3 = e.name;
			let v3 = Reflect.field(this.macros,_g3);
			let pl = [];
			let old = this.buf;
			pl.push($bind(this,this.resolve));
			let _g_head1 = e.params.h;
			while(_g_head1 != null) {
				let val = _g_head1.item;
				_g_head1 = _g_head1.next;
				if(val._hx_index == 0) {
					pl.push(this.resolve(val.v));
				} else {
					this.buf = new StringBuf();
					this.run(val);
					pl.push(this.buf.b);
				}
			}
			this.buf = old;
			try {
				let _this = this.buf;
				let x = Std.string(v3.apply(this.macros,pl));
				_this.b += Std.string(x);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				let plstr;
				try {
					plstr = pl.join(",");
				} catch( _g ) {
					plstr = "???";
				}
				throw haxe_Exception.thrown("Macro call " + _g3 + "(" + plstr + ") failed (" + Std.string(_g1) + ")");
			}
			break;
		}
	}
}
haxe_Template.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
		this.__skipStack++;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	first() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	pop() {
		if(this.h == null) {
			return null;
		}
		let x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	isEmpty() {
		return this.h == null;
	}
	toString() {
		let s_b = "";
		let first = true;
		let l = this.h;
		s_b = "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
}
haxe_ds_List.__name__ = true;
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__:true,__constructs__:null
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_._hx_name="Some",$_.__params__ = ["v"],$_)
	,None: {_hx_name:"None",_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
haxe_ds_Option.__constructs__ = [haxe_ds_Option.Some,haxe_ds_Option.None];
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutDirectory(path) {
		let s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static extension(path) {
		let s = new haxe_io_Path(path);
		if(s.ext == null) {
			return "";
		}
		return s.ext;
	}
	static withExtension(path,ext) {
		let s = new haxe_io_Path(path);
		s.ext = ext;
		return s.toString();
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < paths.length) {
			let v = paths[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return "";
		}
		let path = _g[0];
		let _g2 = 1;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			path = haxe_io_Path.addTrailingSlash(path);
			path += _g[_g2++];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g2_offset = 0;
		let _g2_s = target.join(slash);
		while(_g2_offset < _g2_s.length) {
			let s = _g2_s;
			let index = _g2_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g2_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_Fs = require("fs");
var js_node_Path = require("path");
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _g ) {
			return false;
		}
	}
	static isDirectory(path) {
		try {
			return js_node_Fs.statSync(path).isDirectory();
		} catch( _g ) {
			return false;
		}
	}
	static createDirectory(path) {
		try {
			js_node_Fs.mkdirSync(path);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "ENOENT") {
				sys_FileSystem.createDirectory(js_node_Path.dirname(path));
				js_node_Fs.mkdirSync(path);
			} else {
				let stat;
				try {
					stat = js_node_Fs.statSync(path);
				} catch( _g ) {
					throw _g1;
				}
				if(!stat.isDirectory()) {
					throw _g1;
				}
			}
		}
	}
}
sys_FileSystem.__name__ = true;
var vscode_Diagnostic = require("vscode").Diagnostic;
var vscode_DiagnosticSeverity = require("vscode").DiagnosticSeverity;
var vscode_Range = require("vscode").Range;
var vscode_Uri = require("vscode").Uri;
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
boxup_ReadStream._hx_skip_constructor = false;
boxup_WriteStream._hx_skip_constructor = false;
boxup_cli_DefinitionGenerator.defaultParagraphChildren = [new boxup_cli_ChildDefinition("@italic",null,null,null),new boxup_cli_ChildDefinition("@bold",null,null,null),new boxup_cli_ChildDefinition("@raw",null,null,null)];
boxup_cli_DefinitionGenerator.defaultBlocks = [new boxup_cli_BlockDefinition("@italic",null,"Tag",[],[]),new boxup_cli_BlockDefinition("@bold",null,"Tag",[],[]),new boxup_cli_BlockDefinition("@raw",null,"Tag",[],[])];
var boxup_cli_DefinitionValidator_validator = new boxup_cli_Definition("d",[new boxup_cli_BlockDefinition("@root",null,null,[new boxup_cli_ChildDefinition("Definition",null,null,false),new boxup_cli_ChildDefinition("Root",null,true,false),new boxup_cli_ChildDefinition("Meta",null,null,null),new boxup_cli_ChildDefinition("Block",null,null,null)],[]),new boxup_cli_BlockDefinition("Definition",null,null,[],[new boxup_cli_PropertyDefinition("id",true,true,null,null)]),new boxup_cli_BlockDefinition("Root",null,null,[new boxup_cli_ChildDefinition("Child",null,null,null)],[]),new boxup_cli_BlockDefinition("Block",null,null,[new boxup_cli_ChildDefinition("Child",null,null,null),new boxup_cli_ChildDefinition("Property",null,null,null),new boxup_cli_ChildDefinition("IdProperty",null,null,false),new boxup_cli_ChildDefinition("EnumProperty",null,null,null),new boxup_cli_ChildDefinition("Meta",null,null,null)],[new boxup_cli_PropertyDefinition("kind",null,false,"String",["Tag","Normal","Paragraph"]),new boxup_cli_PropertyDefinition("name",true,true,"String",null)]),new boxup_cli_BlockDefinition("Property",null,null,[],[new boxup_cli_PropertyDefinition("name",true,true,"String",null),new boxup_cli_PropertyDefinition("type",null,false,"String",null),new boxup_cli_PropertyDefinition("required",null,false,"Bool",null),new boxup_cli_PropertyDefinition("type",null,false,"String",["String","Int","Float","Bool"])]),new boxup_cli_BlockDefinition("IdProperty",null,null,[],[new boxup_cli_PropertyDefinition("name",true,true,"String",null),new boxup_cli_PropertyDefinition("type",null,false,"String",null),new boxup_cli_PropertyDefinition("required",null,false,"Bool",null)]),new boxup_cli_BlockDefinition("EnumProperty",null,null,[new boxup_cli_ChildDefinition("Option",null,true,true)],[new boxup_cli_PropertyDefinition("name",true,true,"String",null),new boxup_cli_PropertyDefinition("type",null,false,"String",null),new boxup_cli_PropertyDefinition("required",null,false,"Bool",null)]),new boxup_cli_BlockDefinition("Option",null,null,[],[new boxup_cli_PropertyDefinition("value",null,true,"String",null)]),new boxup_cli_BlockDefinition("Child",null,null,[],[new boxup_cli_PropertyDefinition("name",true,true,"String",null),new boxup_cli_PropertyDefinition("required",null,false,"Bool",null),new boxup_cli_PropertyDefinition("multiple",null,false,"Bool",null),new boxup_cli_PropertyDefinition("symbol",null,null,"String",["!","@","#","%","$","&","^","-",":","<",">","?","+","*"])]),new boxup_cli_BlockDefinition("Meta",null,"PropertyBag",[],[new boxup_cli_PropertyDefinition("metaNamespace",true,null,null,null)])],new haxe_ds_StringMap());
haxe_Template.splitter = new EReg("(::[A-Za-z0-9_ ()&|!+=/><*.\"-]+::|\\$\\$([A-Za-z0-9_-]+)\\()","");
haxe_Template.expr_splitter = new EReg("(\\(|\\)|[ \r\n\t]*\"[^\"]*\"[ \r\n\t]*|[!+=/><*.&|-]+)","");
haxe_Template.expr_trim = new EReg("^[ ]*([^ ]+)[ ]*$","");
haxe_Template.expr_int = new EReg("^[0-9]+$","");
haxe_Template.expr_float = new EReg("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?$","");
haxe_Template.globals = { };
haxe_Template.hxKeepArrayIterator = new haxe_iterators_ArrayIterator([]);
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
